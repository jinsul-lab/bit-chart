<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>/ë¹„íŠ¸/ì™¸ë˜ í†µê³„ ìë™ ê³„ì‚° ë„êµ¬</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 1000px; margin: auto; }
    h1 { color: #2c3e50; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; overflow-x: auto; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    th { background-color: #f4f4f4; }
    .warn { color: red; font-weight: bold; margin-top: 10px; }
    .input-section { margin: 20px 0; }
  </style>
</head>
<body>
  <h1>/ë¹„íŠ¸/ì™¸ë˜ í†µê³„ ìë™ ê³„ì‚°ê¸°</h1>
<p><a href="ysarangchart.html" target="_blank">ğŸ‘‰ ì˜ì‚¬ë‘ í†µê³„ ë³´ê¸°</a></p>

<div>
  <label>íŒŒì¼ ì—…ë¡œë“œ:</label>
  <input type="file" id="fileInput" accept=".xlsx,.csv" />
</div>
  
  <div class="input-section">
    <label>âœ”ï¸ íŠ¹ì • í‚¤ì›Œë“œ(ì˜ˆ: PTë§Œ)ë¥¼ ì…ë ¥í•˜ì„¸ìš”:</label><br>
    <input type="text" id="keywordInput" placeholder="ì˜ˆ: PTë§Œ" style="width: 200px; margin-top: 5px;" />
  </div>

  <input type="file" id="fileInput" accept=".xlsx,.csv" />
  <div id="output"></div>
  <div id="warning" class="warn"></div>

  <script>
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      const keyword = document.getElementById('keywordInput').value.trim().toLowerCase();
      const reader = new FileReader();
      const isCSV = file.name.endsWith('.csv');

      reader.onload = function(e) {
        let rawData = [];

        if (isCSV) {
          const csv = e.target.result;
          const rows = csv.split(/\r?\n/).map(row => row.split(','));
          rawData = rows;
          process(rawData, keyword);
        } else {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          workbook.SheetNames.forEach(sheet => {
            const sheetData = XLSX.utils.sheet_to_json(workbook.Sheets[sheet], { header: 1, defval: "" });
            rawData = rawData.concat(sheetData);
          });
          process(rawData, keyword);
        }
      };

      if (isCSV) reader.readAsText(file);
      else reader.readAsArrayBuffer(file);
    });

    function process(rawData, keyword) {
      const headerRowIndex = rawData.findIndex(
        row => row.join('').includes("ì´ˆ/ì¬") || row.join('').includes("ì± íŠ¸ë²ˆí˜¸") || row.join('').includes("ì§„ë£Œê³¼") || row.join('').includes("ë§ˆì·¨")
      );

      if (headerRowIndex === -1) {
        document.getElementById('warning').innerText = 'â— ìœ íš¨í•œ ì—´ ì´ë¦„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
        return;
      }

      const headers = rawData[headerRowIndex].map(h => h.toString().trim());
      const dataRows = rawData.slice(headerRowIndex + 1).filter(r => r.length > 1);
      const df = dataRows.map(row => {
        let obj = {};
        headers.forEach((col, i) => { obj[col] = row[i] || ""; });
        return obj;
      });

      const headerMap = {};
      headers.forEach(h => {
        const lname = h.toLowerCase();
        if (lname.includes("ì´ˆ") && lname.includes("ì¬")) headerMap['ì´ˆì¬'] = h;
        else if (lname.includes("ì°¨íŠ¸") || lname.includes("ì± íŠ¸") || lname.includes("í™˜ì") || lname.includes("id")) headerMap['ì± íŠ¸ë²ˆí˜¸'] = h;
        else if (lname.includes("ë§ˆì·¨")) headerMap['ë§ˆì·¨'] = h;
        else if ((lname.includes("ì§„ë£Œ") && lname.includes("ê³¼")) || lname.includes("ê³¼ëª©")) headerMap['ì§„ë£Œê³¼'] = h;
        else if (lname.includes("ë©”ëª¨")) headerMap['ì ‘ìˆ˜ë©”ëª¨'] = h;
      });

      const í•„ìˆ˜ = ['ì´ˆì¬', 'ì± íŠ¸ë²ˆí˜¸', 'ë§ˆì·¨', 'ì§„ë£Œê³¼'];
      const ëˆ„ë½ = í•„ìˆ˜.filter(k => !headerMap[k]);
      if (ëˆ„ë½.length) {
        document.getElementById('warning').innerText = `â— í•„ìˆ˜ ì—´ ëˆ„ë½: ${ëˆ„ë½.join(', ')}`;
        return;
      }

      const ì¬ì§„ì¡°ê±´ = ["ì¬ì§„", "ë¬¼ë¦¬ì¹˜ë£Œë‚´ì›", "ì§„ì°°ë£Œ ì‚°ì •ì•ˆí•¨"];
      const ì§„ë£Œì‹¤ëª©ë¡ = [...new Set(df.map(r => r[headerMap['ì§„ë£Œê³¼']] || 'ê¸°íƒ€'))];

      function countStats(data, ì§„ë£Œì‹¤) {
        const sub = ì§„ë£Œì‹¤ === "ì „ì²´" ? data : data.filter(r => (r[headerMap['ì§„ë£Œê³¼']] || 'ê¸°íƒ€') === ì§„ë£Œì‹¤);
        const ì´ˆì§„í™˜ì = sub.filter(r => ["ì‹ í™˜", "90ì¼ì´ˆì§„"].includes(r[headerMap['ì´ˆì¬']]));
        const ì´ˆì§„ì°¨íŠ¸ = [...new Set(ì´ˆì§„í™˜ì.map(r => r[headerMap['ì± íŠ¸ë²ˆí˜¸']]))];
        const ì¬ì§„ë°©ë¬¸ìˆ˜ = sub.filter(r => ì¬ì§„ì¡°ê±´.includes(r[headerMap['ì´ˆì¬']])).length;
        const ì´ë°©ë¬¸ìˆ˜ = sub.length;

        const ì´ˆì§„ì£¼ì‚¬ = ì´ˆì§„í™˜ì.filter(r => (r[headerMap['ë§ˆì·¨']] || '').includes('â—'));
        const ì´ˆì§„ì£¼ì‚¬ê°¯ìˆ˜ = ì´ˆì§„ì£¼ì‚¬.length;
        const ì´ˆì§„ì£¼ì‚¬ì²˜ë°©ë¥  = ì´ˆì§„ì°¨íŠ¸.length ? Math.round((ì´ˆì§„ì£¼ì‚¬.length / ì´ˆì§„ì°¨íŠ¸.length) * 100) : 0;

        const ì£¼ì‚¬ì°¨íŠ¸ = [...new Set(ì´ˆì§„ì£¼ì‚¬.map(r => r[headerMap['ì± íŠ¸ë²ˆí˜¸']]))];
        const ì£¼ì‚¬ê¸°ë¡ = sub.filter(r => ì£¼ì‚¬ì°¨íŠ¸.includes(r[headerMap['ì± íŠ¸ë²ˆí˜¸']]));

        const ì£¼ì‚¬íšŸìˆ˜ = {}, ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬ = {};
        ì£¼ì‚¬ê¸°ë¡.forEach(r => {
          const key = r[headerMap['ì± íŠ¸ë²ˆí˜¸']];
          if ((r[headerMap['ë§ˆì·¨']] || '').includes('â—')) {
            ì£¼ì‚¬íšŸìˆ˜[key] = (ì£¼ì‚¬íšŸìˆ˜[key] || 0) + 1;
          }
          ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬[key] = (ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬[key] || 0) + 1;
        });

        const í‰ê· ì£¼ì‚¬íšŸìˆ˜ = Object.keys(ì£¼ì‚¬íšŸìˆ˜).length ? (Object.values(ì£¼ì‚¬íšŸìˆ˜).reduce((a, b) => a + b, 0) / Object.keys(ì£¼ì‚¬íšŸìˆ˜).length).toFixed(1) : 0;
        const í‰ê· ë‚´ì›ì£¼ì‚¬ = Object.keys(ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬).length ? (Object.values(ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬).reduce((a, b) => a + b, 0) / Object.keys(ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬).length).toFixed(1) : 0;

        const ì „ì²´ì´ˆì§„ê¸°ë¡ = sub.filter(r => ì´ˆì§„ì°¨íŠ¸.includes(r[headerMap['ì± íŠ¸ë²ˆí˜¸']]));
        const ì´ˆì§„ë‚´ì› = {};
        ì „ì²´ì´ˆì§„ê¸°ë¡.forEach(r => {
          const key = r[headerMap['ì± íŠ¸ë²ˆí˜¸']];
          ì´ˆì§„ë‚´ì›[key] = (ì´ˆì§„ë‚´ì›[key] || 0) + 1;
        });

        const ì´ˆì§„í‰ê· ë‚´ì› = Object.keys(ì´ˆì§„ë‚´ì›).length ? (Object.values(ì´ˆì§„ë‚´ì›).reduce((a, b) => a + b, 0) / Object.keys(ì´ˆì§„ë‚´ì›).length).toFixed(1) : 0;
        const ì¬ë‚´ì›ìˆ˜ = Object.values(ì´ˆì§„ë‚´ì›).filter(n => n >= 2).length;
        const ì´ˆì§„ì¬ë‚´ì›ìœ¨ = Object.keys(ì´ˆì§„ë‚´ì›).length ? Math.round((ì¬ë‚´ì›ìˆ˜ / Object.keys(ì´ˆì§„ë‚´ì›).length) * 100) : 0;

        const ë‚´ì›ë¹„ìœ¨ = count => Math.round((Object.values(ì´ˆì§„ë‚´ì›).filter(n => n === count).length / Object.keys(ì´ˆì§„ë‚´ì›).length) * 100);
        const ë‚´ì›ë¹„ìœ¨_5ì´ìƒ = Math.round((Object.values(ì´ˆì§„ë‚´ì›).filter(n => n >= 5).length / Object.keys(ì´ˆì§„ë‚´ì›).length) * 100);

        const ë©”ëª¨ê°¯ìˆ˜ = headerMap['ì ‘ìˆ˜ë©”ëª¨'] && keyword
          ? sub.filter(r => (r[headerMap['ì ‘ìˆ˜ë©”ëª¨']] || "").toLowerCase().trim() === keyword).length
          : "";

        return {
          "êµ¬ë¶„": ì§„ë£Œì‹¤,
          "ì´ˆì§„í™˜ììˆ˜": ì´ˆì§„ì°¨íŠ¸.length,
          "ì¬ì§„í™˜ììˆ˜": ì¬ì§„ë°©ë¬¸ìˆ˜,
          "ì´í™˜ììˆ˜": ì´ë°©ë¬¸ìˆ˜,
          "ì´ˆì§„ ì£¼ì‚¬ ì²˜ë°©ë¥ ": `${ì´ˆì§„ì£¼ì‚¬ì²˜ë°©ë¥ }%`,
          "ì´ˆì§„ì£¼ì‚¬ ê°¯ìˆ˜": ì´ˆì§„ì£¼ì‚¬ê°¯ìˆ˜,
          "ì´ˆì§„ ì£¼ì‚¬í™˜ì ì¬ì§„ìœ¨": `${Math.round((Object.values(ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬).filter(v => v >= 2).length / Object.keys(ë‚´ì›íšŸìˆ˜_ì£¼ì‚¬).length) * 100) || 0}%`,
          "ì´ˆì§„ì£¼ì‚¬í™˜ì í‰ê·  ì£¼ì‚¬íšŸìˆ˜": í‰ê· ì£¼ì‚¬íšŸìˆ˜,
          "ì´ˆì§„ ì£¼ì‚¬í™˜ì í‰ê· ë‚´ì›íšŸìˆ˜": í‰ê· ë‚´ì›ì£¼ì‚¬,
          "ì´ˆì§„í‰ê· ë‚´ì›íšŸìˆ˜": ì´ˆì§„í‰ê· ë‚´ì›,
          "ì´ˆì§„ ì¬ë‚´ì›ìœ¨": `${ì´ˆì§„ì¬ë‚´ì›ìœ¨}%`,
          "1íšŒ ë‚´ì› ë¹„ìœ¨": `${ë‚´ì›ë¹„ìœ¨(1)}%`,
          "2íšŒ ë‚´ì› ë¹„ìœ¨": `${ë‚´ì›ë¹„ìœ¨(2)}%`,
          "3íšŒ ë‚´ì› ë¹„ìœ¨": `${ë‚´ì›ë¹„ìœ¨(3)}%`,
          "4íšŒ ë‚´ì› ë¹„ìœ¨": `${ë‚´ì›ë¹„ìœ¨(4)}%`,
          "5íšŒ ì´ìƒ ë‚´ì› ë¹„ìœ¨": `${ë‚´ì›ë¹„ìœ¨_5ì´ìƒ}%`,
          "íŠ¹ì • í‚¤ì›Œë“œ í¬í•¨ ë©”ëª¨ ìˆ˜": ë©”ëª¨ê°¯ìˆ˜
        };
      }

      const í†µê³„ = [countStats(df, "ì „ì²´")].concat(ì§„ë£Œì‹¤ëª©ë¡.map(j => countStats(df, j)));
      const keys = Object.keys(í†µê³„[0]);
      let html = '<table><thead><tr>' + keys.map(k => `<th>${k}</th>`).join('') + '</tr></thead><tbody>';
      í†µê³„.forEach(row => {
        html += '<tr>' + keys.map(k => `<td>${row[k]}</td>`).join('') + '</tr>';
      });
      html += '</tbody></table>';
      document.getElementById('output').innerHTML = html;
    }
  </script>
</body>
</html>
