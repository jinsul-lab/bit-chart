<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>JINSUL - 전략 분석 시스템 (도수치료) (v 0.0.4.4)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root { --blue: #228be6; --border: rgba(0, 0, 0, 0.1); --text: #1f2937; --gray: #868e96; }
    * { box-sizing: border-box; font-family: system-ui, sans-serif; }
    body { margin: 0; background: #f8f9fa; color: var(--text); min-height: 100vh; display: flex; flex-direction: column; overflow-x: hidden; }

    .version-tag { position: absolute; top: 10px; left: 10px; font-size: 10px; color: var(--gray); opacity: 0.5; font-weight: bold; }

    .watermark { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 550px; opacity: 0.1; z-index: -1; pointer-events: none; filter: grayscale(1); }

    header { padding: 40px 0 20px; text-align: center; }
    header img { width: 180px; filter: grayscale(1) brightness(0.5); margin-bottom: 10px; }

    .container { max-width: 1260px; margin: 0 auto; padding: 0 10px; flex: 1; width: 100%; }

    .card { background: rgba(255, 255, 255, 0); padding: 14px; border-radius: 12px; border: 1px solid var(--border); margin-bottom: 10px; }
    .card h2 { margin: 0 0 10px; font-size: 16px; border-left: 4px solid var(--blue); padding-left: 10px; }

    .drop-zone {border: 2px dashed #cbd5e1; padding: 26px; text-align: center; border-radius: 10px; background: rgba(255, 255, 255, 0.5); cursor: pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; width:100%; box-sizing:border-box; min-height:96px; }
    .drop-zone.active { border-color: var(--blue); background: rgba(34, 139, 230, 0.1); }

    .cards-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 20px; }
    @media (max-width: 980px){ .cards-grid{ grid-template-columns: 1fr; } }

    .dashboard-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(190px, 1fr)); gap: 8px; margin-bottom: 10px; }
    .dash-item { background: #fff; padding: 12px; border-radius: 10px; border: 1px solid var(--border); text-align: center; }
    .dash-item .val { font-size: 24px; font-weight: 800; color: var(--blue); }
    .dash-item .sub { font-size: 11px; color: var(--gray); margin-top: 3px; }

    .price-btn { padding: 5px 10px; border-radius: 6px; border: 1px solid #dee2e6; background: #fff; cursor: pointer; font-size: 12px; margin: 2px; transition: 0.2s; }
    .price-btn.active { background: var(--blue); color: #fff; border-color: var(--blue); font-weight: bold; box-shadow: 0 2px 4px rgba(34, 139, 230, 0.3); }

    .price-btn.excl-btn { border-style: dashed; }
    .price-btn.excl-btn.active { background: var(--gray); color: #fff; border-color: var(--gray); box-shadow: none; font-weight: bold; }

    .filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 980px){ .filter-grid{ grid-template-columns: 1fr; } }

    table { width: 100%; border-collapse: collapse; background: transparent; table-layout: fixed; }
    th { background: rgba(241, 243, 245, 0.85); padding: 7px 6px; border: 1px solid #dee2e6; text-align: center; font-size: 12px; }
    td { padding: 7px 6px; border: 1px solid var(--border); font-size: 12px; text-align: center; }
    .total-col { background: rgba(34, 139, 230, 0.1); font-weight: bold; }
    .total-row td { background: rgba(34, 139, 230, 0.08); font-weight: bold; }
    .hidden { display: none; }
    .file-hidden{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }

    footer { text-align: center; padding: 30px 20px; color: var(--gray); font-size: 0.95rem; font-weight: 500; width: 100%; position: relative; z-index: 10; }
  
    /* --- Added: Subtables & Follow-up summary --- */
    .subtablesGrid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(360px, 1fr)); gap:12px; }
    .miniCard{ border:1px solid #e9ecef; border-radius: 10px; background:#fff; padding:10px; }
    .miniTitle{ font-weight:700; margin:0 0 6px 0; display:flex; justify-content:space-between; align-items:baseline; font-size:13px; }
    .miniSub{ font-weight:500; color:#666; font-size:12px; }
    .mini-table{ width:100%; border-collapse:collapse; table-layout:fixed; }
    .mini-table th, .mini-table td{ padding:6px 6px; font-size:12px; }
    .mini-table th{ white-space:nowrap; }
    .table-scroll{ overflow-x:auto; }
    .proposalWrap{ display:grid; grid-template-columns: 1fr; gap:12px; align-items:start; }
    
    .proposalPanel{ background: rgba(255,255,255,0.75); border:1px solid #d0ebff; border-radius: 12px; padding:12px; }
@media (max-width: 900px){ .proposalWrap{ grid-template-columns: 1fr; } .subtablesGrid{ grid-template-columns: 1fr; } }
    .followSummary{ background: rgba(255,255,255,0.75); border:1px solid #d0ebff; border-radius: 12px; padding:12px; }
    .followSummary .title{ font-weight:700; margin-bottom:6px; }
    .followSummary ol{ margin:0; padding-left:18px; }
    .followSummary li{ margin:0 0 8px 0; }
    .followSummary .meta{ font-size:12px; color:#555; margin-top:2px; }
    .kpiLines div{ margin:0; }
    
  .cardHeaderRow{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
.toggleBtn{ border:1px solid #cfe3ff; background:#fff; padding:6px 10px; border-radius:10px; font-size:12px; cursor:pointer; }
.toggleBtn:hover{ background:#f8fbff; }
.collapseWrap.collapsed{ display:none; }
.kpiRowLabel{ font-weight:600; }
</style>
</head>
<body>
  <div class="version-tag">v 0.0.4.4</div>
  <img src="jinsul-logo.png" class="watermark" alt="bg" />
  <header>
    <img src="jinsul-logo.png" alt="logo" />
    <div style="font-weight: bold; font-size: 18px;">신환 도수치료 전략 분석 리포트</div>
  </header>

  <div class="container">
    <div class="card">
      <label class="drop-zone" id="dropZone" for="fileInput">
        <strong id="statusText">데이터 업로드 (드래그/클릭)</strong>
        <input type="file" id="fileInput" class="file-hidden" accept=".csv, .xlsx, .xls" />
      </label>
    </div>

    <div id="dashArea" class="dashboard-grid hidden">
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">신환 수</div>
        <div id="v-count" class="val">0</div>
        <div id="v-count-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">2회 이상 치료 비율</div>
        <div id="v-conv" class="val">0%</div>
        <div id="v-conv-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">3회 이상 치료 비율</div>
        <div id="v-ret" class="val">0%</div>
        <div id="v-ret-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">주사치료 병행 비율</div>
        <div id="v-combo" class="val">0%</div>
        <div id="v-combo-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">평균 치료 횟수</div>
        <div id="v-avgV" class="val">0.0</div>
        <div class="sub">도수치료 치료일 기준</div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">중간값 치료 횟수</div>
        <div id="v-medV" class="val">0</div>
        <div class="sub">도수치료 치료일 기준</div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">가장 흔한 치료 횟수(최빈값)</div>
        <div id="v-modeV" class="val">-</div>
        <div id="v-modeV-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">7일 내 재방문율</div>
        <div id="v-r7" class="val">0%</div>
        <div id="v-r7-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">14일 내 재방문율</div>
        <div id="v-r14" class="val">0%</div>
        <div id="v-r14-sub" class="sub"></div>
      </div>
</div>

    <div id="filterArea" class="card hidden">
  <h2>치료 금액 선택</h2>
  <div class="filter-grid">
    <div>
      <div style="font-size:13px;color:var(--gray);margin-bottom:6px;">포함할 치료 금액 (단일 선택)</div>
      <div id="priceBtns"></div>
    </div>
    <div>
      <div style="font-size:13px;color:var(--gray);margin-bottom:6px;">제외할 치료 금액 (복수 선택)</div>
      <div id="excludeBtns"></div>
      <div style="font-size:12px;color:var(--gray);margin-top:4px;">※ 제외된 금액으로 시작한 신환은 분석에서 제외됩니다.</div>
    </div>
  </div>
</div>

<div id="mainContent" class="hidden">
      <div class="cards-grid">
      <div class="card"><h2>표 1. 진료실별 치료 횟수</h2><div style="overflow-x:auto;"><table id="table1"></table></div></div>
      <div class="card"><h2>표 2. 신환 상세 통계 및 재진 전환율</h2><div style="overflow-x:auto;"><table id="table2"></table></div></div>
      <div class="card"><h2>표 3. 연령대별 도수치료 치료 건수</h2><div style="overflow-x:auto;"><table id="table3"></table></div></div>
      <div class="card"><h2>표 4. 연령대별 성별 치료 비중</h2><div style="overflow-x:auto;"><table id="table4"></table></div></div>
      <div class="card"><h2>표 5. 도수치료 치료 횟수 분포</h2><div style="overflow-x:auto;"><table id="table5"></table></div></div>
      <div class="card"><h2>표 6. 연령대별 치료 횟수 인원 분포</h2><div style="overflow-x:auto;"><table id="table6"></table></div></div>

      <div class="card"><h2>표 7. 치료 금액 구간별 핵심지표</h2><div style="overflow-x:auto;"><table id="table7"></table></div></div>
      <div class="card"><h2>표 8. 치료사별 핵심지표</h2><div style="overflow-x:auto;"><table id="table8"></table></div></div>
      <div class="card"><h2>표 8-1. 도수치료 치료사별 신환/재진 예약 비율(O/X)</h2><div style="overflow-x:auto;"><table id="table8r"></table></div></div>
      <div class="card"><h2>표 9. 첫 치료 → 2회차 재방문 주기</h2><div style="overflow-x:auto;"><table id="table9"></table></div></div>

      
      <div class="card"><h2>표 10. 진료실별 핵심지표</h2><div style="overflow-x:auto;"><table id="table10"></table></div></div>
      <div class="card"><h2>표 11. 치료사별·연령대별 평균 치료 횟수</h2><div style="overflow-x:auto;"><table id="table11"></table></div></div>
      <div class="card"><h2>표 12. 치료사별·연령대별 치료 횟수 분포</h2><div id="table12"></div></div>

            <div class="card" id="card13">
  <div class="cardHeaderRow">
    <h2>표 13. 치료사별·연령대별 재방문 안내 연락 시점 및 예약 확인(권장)</h2>
    <button id="toggle13" class="toggleBtn" type="button">펼치기</button>
  </div>
  <div id="table13Wrap" class="collapseWrap collapsed">
    <div id="table13"></div>
    <div id="followSummary13" class="followSummary" style="margin-top:10px;"></div>
  </div>
</div>

<div class="card" style="background: rgba(231, 245, 255, 0.6);">
        <h2>병원 경영 전략 제안서</h2>
        <div class="proposalWrap"><div id="analysisText" class="proposalPanel" style="line-height:1.7; font-size:13px; color:#333; padding: 12px;"></div></div>
      </div>
      </div>
    </div>
  </div>

  <footer>© JINSUL · 경험과 가치를 현실화하는 컨설팅</footer>

  <script>


    // -----------------------------
    // 0) UI 이벤트
    // -----------------------------
    const dz = document.getElementById('dropZone');
    const fi = document.getElementById('fileInput');

    // 전역 드래그 기본동작 방지 (드롭 시 브라우저가 파일을 열어버리는 현상 방지)
    window.addEventListener('dragover', e => e.preventDefault());
    window.addEventListener('drop', e => e.preventDefault());

    function getDroppedFile(dt){
      if(!dt) return null;
      if(dt.files && dt.files.length) return dt.files[0];
      if(dt.items){
        for(const it of dt.items){
          if(it && it.kind === 'file') return it.getAsFile();
        }
      }
      return null;
    }

    fi.onchange = e => handleFile(e.target.files && e.target.files[0]);

    // 표 13 펼치기/접기
    const toggle13Btn = document.getElementById('toggle13');
    const table13Wrap = document.getElementById('table13Wrap');
    if(toggle13Btn && table13Wrap){
      toggle13Btn.addEventListener('click', ()=>{
        const nowCollapsed = table13Wrap.classList.toggle('collapsed');
        toggle13Btn.textContent = nowCollapsed ? '펼치기' : '접기';
      });
    }


    ['dragenter','dragover'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); dz.classList.add('active'); }));
    ['dragleave','drop'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); dz.classList.remove('active'); }));
    dz.addEventListener('drop', e => handleFile(getDroppedFile(e.dataTransfer)));

    // -----------------------------
    // 1) 전역 상태
    // -----------------------------
    let rawRows = [];
    let records = [];     // row-level cleaned
    let patientsAll = []; // patient-level aggregated (전체)
    let selPVal = -1;     // selected entry price
    let entryPriceList = [];
    let amountListAll = [];
    let exclAmtSet = new Set();

    const AGE_BUCKETS = ['10대','20대','30대','40대','50대','60대','70대 이상','미상'];
    const GENDERS = ['남','여','미상'];

    function toStr(v){ return (v===null||v===undefined) ? "" : String(v); }
    function normKey(k){ return toStr(k).trim(); }
    function num(v){
      const n = parseInt(toStr(v).replace(/[^0-9]/g,''),10);
      return isFinite(n) ? n : 0;
    }

    function moneyOrNull(v){
      // 금액 파싱: 숫자가 전혀 없으면 null(없음)로 처리 (공란을 0원으로 만들지 않기 위함)
      if(v===null || v===undefined) return null;
      if(typeof v === 'number' && isFinite(v)) return Math.round(v);
      const digits = toStr(v).replace(/[^0-9]/g,'');
      if(!digits) return null;
      const n = parseInt(digits,10);
      return isFinite(n) ? n : null;
    }

    function normalizeType(v){
      const s = toStr(v).replace(/\s+/g,'').replace(/,+/g,'').trim();
      return s;
    }
    function isShock(t){ return normalizeType(t).includes('도수'); }
    function isInjection(t){ const s=normalizeType(t); return s.includes('주사'); }
    function isManual(t){ return normalizeType(t).includes('도수'); }

    function parseVisitDate(v){
      // returns Date or null
      if(v===null || v===undefined || v==="") return null;

      // number: could be yyyymmdd (e.g., 20251101.0) or excel serial (e.g., 45200)
      if(typeof v === 'number' && isFinite(v)){
        const iv = Math.floor(v);
        const s = String(iv);
        if(s.length === 8 && iv > 19000101 && iv < 20991231){
          const y = parseInt(s.slice(0,4),10);
          const m = parseInt(s.slice(4,6),10)-1;
          const d = parseInt(s.slice(6,8),10);
          const dt = new Date(y,m,d);
          return isFinite(dt.getTime()) ? dt : null;
        }
        // excel serial heuristic
        if(iv > 20000 && iv < 60000){
          const base = new Date(Date.UTC(1899,11,30)); // Excel epoch
          const dt = new Date(base.getTime() + iv * 86400000);
          return isFinite(dt.getTime()) ? new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()) : null;
        }
      }

      // string formats
      const s0 = toStr(v).trim();
      if(!s0) return null;

      // yyyymmdd as string
      const s = s0.replace(/\s+/g,'');
      if(/^\d{8}(\.0+)?$/.test(s)){
        const s8 = s.slice(0,8);
        const y = parseInt(s8.slice(0,4),10);
        const m = parseInt(s8.slice(4,6),10)-1;
        const d = parseInt(s8.slice(6,8),10);
        const dt = new Date(y,m,d);
        return isFinite(dt.getTime()) ? dt : null;
      }

      // yyyy-mm-dd / yyyy/mm/dd
      const m1 = s.match(/^(\d{4})[-\/.](\d{1,2})[-\/.](\d{1,2})/);
      if(m1){
        const y = parseInt(m1[1],10);
        const mo = parseInt(m1[2],10)-1;
        const d = parseInt(m1[3],10);
        const dt = new Date(y,mo,d);
        return isFinite(dt.getTime()) ? dt : null;
      }

      const dt = new Date(s0);
      return isFinite(dt.getTime()) ? new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()) : null;
    }


    function normalizeRecords(recs){
      // 방문(환자+방문일+치료타입+회차+치료사) 단위로 묶어서,
      // 금액이 비어있는 행(부위가 분리 출력된 행)에도 같은 방문 금액을 전파한다.
      const g = new Map();
      const keyOf = (r)=>[r.key, r.therapist||'', String(r.visitKey||''), normalizeType(r.typeRaw||''), toStr(r.round||'')].join('||');
      for(const r of recs){
        const k = keyOf(r);
        if(!g.has(k)) g.set(k, []);
        g.get(k).push(r);
      }
      for(const rows of g.values()){
        const amts = rows.map(x=>x.amount).filter(v=>isFinite(v) && v>0);
        const a = amts.length ? Math.max(...amts) : null;
        if(a!==null){
          rows.forEach(x=>{ if(x.amount===null || x.amount===undefined || x.amount===0) x.amount = a; });
        }
        const t = rows.map(x=>toStr(x.typeRaw).trim()).find(v=>v) || '';
        const rd = rows.map(x=>toStr(x.round).trim()).find(v=>v) || '';
        const nf = rows.map(x=>toStr(x.newFlag).trim()).find(v=>v) || '';
        const rv = rows.map(x=>toStr(x.reserve).trim()).find(v=>v) || '';
        const rm = rows.map(x=>toStr(x.room).trim()).find(v=>v) || '';
        rows.forEach(x=>{
          if(!toStr(x.typeRaw).trim()) x.typeRaw = t;
          if(!toStr(x.round).trim()) x.round = rd;
          if(!toStr(x.newFlag).trim()) x.newFlag = nf;
          if(!toStr(x.reserve).trim()) x.reserve = rv;
          if(!toStr(x.room).trim()) x.room = rm;
        });
      }
      return recs;
    }


    function dateKey(d){
      if(!d) return null;
      const dd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
      return dd.getTime();
    }

    function parseGender(sexAge){
      const s = toStr(sexAge);
      if(s.includes('남')) return '남';
      if(s.includes('여')) return '여';
      return '미상';
    }
    function parseAgeBucket(sexAge){
      const s = toStr(sexAge);
      const m = s.match(/(\d{1,3})/);
      if(!m) return '미상';
      const age = parseInt(m[1],10);
      if(!isFinite(age)) return '미상';
      if(age < 20) return '10대';
      if(age < 30) return '20대';
      if(age < 40) return '30대';
      if(age < 50) return '40대';
      if(age < 60) return '50대';
      if(age < 70) return '60대';
      return '70대 이상';
    }

    
function mapPartSingle(partRaw){
  const s0 = toStr(partRaw).trim();
  if(!s0) return null;
  const s = s0.replace(/\s+/g,'').replace(/[，]/g,'').replace(/,+/g,'').replace(/[.]+$/,'');
  const has = (w)=>s.includes(w);
  // 손가락/발가락 포함 규칙 반영
  if(has('경추') || has('목')) return '목';
  if(has('흉추') || (has('등') && !has('허리'))) return '등';
  if(has('요추') || has('허리')) return '허리';
  if(has('어깨') || has('견')) return '어깨';
  if(has('팔꿈치') || has('주관절')) return '팔꿈치';
  if(has('손가락') || has('수지') || has('손목') || has('손')) return '손목/손';
  if(has('고관절') || has('골반') || has('둔부') || has('엉덩') || has('서혜')) return '골반/고관절';
  if(has('무릎') || has('슬관절')) return '무릎';
  if(has('발가락') || has('족지') || has('발목') || has('발')) return '발목/발';
  return '기타';
}

function extractParts(partRaw){
  const s0 = toStr(partRaw).trim();
  if(!s0) return ['(미기입)'];

  const s = s0
    .replace(/\n/g, ',')
    .replace(/[\/／]/g, ',')
    .replace(/[·•]/g, ',')
    .replace(/\s*및\s*/g, ',')
    .replace(/&/g, ',');

  const tokens = s.split(',').map(x=>x.trim()).filter(Boolean);
  const out = [];
  const push = (v)=>{ if(v && !out.includes(v)) out.push(v); };

  if(tokens.length){
    tokens.forEach(t=>{
      const m = mapPartSingle(t);
      push(m || '기타');
    });
  }else{
    const m = mapPartSingle(s0);
    push(m || '기타');
  }

  return out.length ? out : ['(미기입)'];
}

function fmtPct(x){ return (isFinite(x) ? (x*100).toFixed(1) : '0.0') + '%'; }
    function fmtInt(x){ return (isFinite(x) ? Math.round(x).toLocaleString() : '0'); }
    function median(arr){
      const a = arr.slice().sort((x,y)=>x-y);
      if(!a.length) return 0;
      const mid = Math.floor(a.length/2);
      return a.length%2 ? a[mid] : (a[mid-1]+a[mid])/2;
    }

    function modeInfo(arr){
      const freq = new Map();
      for(const v of (arr||[])){
        const k = (v===null||v===undefined) ? null : Number(v);
        if(!isFinite(k)) continue;
        freq.set(k, (freq.get(k)||0) + 1);
      }
      if(!freq.size) return {modes:[], maxFreq:0};
      let maxF = 0;
      for(const c of freq.values()) maxF = Math.max(maxF, c);
      const modes = Array.from(freq.entries()).filter(([k,c])=>c===maxF).map(([k])=>k).sort((a,b)=>a-b);
      return {modes, maxFreq:maxF};
    }


    

// -----------------------------
// 1.5) 엑셀 파싱(헤더가 깨져도 안정적으로)
//  - 일부 ERP 엑셀은 헤더가 병합되어 '치료차수...예약'처럼 뭉치거나 빈 헤더가 생깁니다.
//  - 그 경우에도 컬럼 위치(A~Q)를 기준으로 안정적으로 읽습니다.
// -----------------------------
function pickBestSheetName(wb){
  const names = wb.SheetNames || [];
  if(!names.length) return null;

  let best = names[0];
  let bestScore = -1;

  for(const name of names){
    const ws = wb.Sheets[name];
    if(!ws) continue;
    const aoa = XLSX.utils.sheet_to_json(ws, {header:1, defval:""});
    if(!aoa || !aoa.length) continue;

    // header row 후보 찾기
    let headerIdx = -1;
    for(let i=0;i<Math.min(30, aoa.length); i++){
      const r = aoa[i] || [];
      const c0 = toStr(r[0]).trim();
      const c2 = toStr(r[2]).trim();
      if(c0 === '번호' && c2 === '이름'){ headerIdx = i; break; }
    }

    // 데이터 행 수(대략)
    let dataCount = 0;
    for(let i=(headerIdx>=0?headerIdx+1:0); i<aoa.length; i++){
      const r = aoa[i] || [];
      const filled = r.slice(0, 8).some(v => toStr(v).trim() !== '');
      if(filled) dataCount++;
    }

    // 점수: header 발견 + 데이터량
    const score = (headerIdx>=0 ? 10000 : 0) + dataCount;
    if(score > bestScore){
      bestScore = score;
      best = name;
    }
  }
  return best;
}

function extractRowsFromWorkbook(wb){
  const sheetName = pickBestSheetName(wb);
  const ws = sheetName ? wb.Sheets[sheetName] : wb.Sheets[wb.SheetNames[0]];
  if(!ws) return [];

  const aoa = XLSX.utils.sheet_to_json(ws, {header:1, defval:""});
  if(!aoa || !aoa.length) return [];

  // 헤더 행 찾기 ('번호' / '이름' 기준)
  let headerIdx = -1;
  for(let i=0;i<Math.min(50, aoa.length); i++){
    const r = aoa[i] || [];
    if(toStr(r[0]).trim()==='번호' && toStr(r[2]).trim()==='이름'){
      headerIdx = i; break;
    }
  }
  if(headerIdx < 0) headerIdx = 0;

  const out = [];
  for(let i=headerIdx+1; i<aoa.length; i++){
    const r = aoa[i] || [];
    // 완전 공백행 스킵
    if(!r.length || r.every(v => toStr(v).trim()==='')) continue;

    // ERP 포맷(치료부위 유무에 따라 컬럼이 1칸씩 달라질 수 있음)
// ① 충격파(부위 있음): 번호, 차트, 이름, 성별/연령, 신/재, 치료부위, 치료차수, 진료실, 금액, 인센, 예약, 차트작성, 방문일, 등록일, 치료타입, 비고, 총
// ② 도수(부위 없음): 번호, 차트, 이름, 성별/연령, 신/재, 치료차수, 진료실, 금액, 인센, 예약, 차트작성, 방문일, 등록일, 치료타입, 비고, 총
const headerRow = aoa[headerIdx] || [];
const hasPartCol = headerRow.some(v => toStr(v).trim() === '치료부위');

const idx = {
  no: 0, chart: 1, name: 2, sexAge: 3, newFlag: 4,
  part: hasPartCol ? 5 : null,
  round: hasPartCol ? 6 : 5,
  room:  hasPartCol ? 7 : 6,
  amount:hasPartCol ? 8 : 7,
  incent:hasPartCol ? 9 : 8,
  reserve:hasPartCol ? 10 : 9,
  chartWrite:hasPartCol ? 11 : 10,
  visitDate:hasPartCol ? 12 : 11,
  regDate: hasPartCol ? 13 : 12,
  type:    hasPartCol ? 14 : 13,
  memo:    hasPartCol ? 15 : 14,
  total:   hasPartCol ? 16 : 15
};

const obj = {
  '번호': r[idx.no] ?? '',
  '환자 차트': r[idx.chart] ?? '',
  '이름': r[idx.name] ?? '',
  '성별/연령': r[idx.sexAge] ?? '',
  '신/재': r[idx.newFlag] ?? '',
  '치료부위': (idx.part===null ? '' : (r[idx.part] ?? '')),
  '치료차수': r[idx.round] ?? '',
  '진료실': r[idx.room] ?? '',
  '금액': r[idx.amount] ?? '',
  '인센': r[idx.incent] ?? '',
  '예약': r[idx.reserve] ?? '',
  '차트작성': r[idx.chartWrite] ?? '',
  '방문일': r[idx.visitDate] ?? '',
  '등록일': r[idx.regDate] ?? '',
  '치료타입': r[idx.type] ?? '',
  '비고': r[idx.memo] ?? '',
  '총': r[idx.total] ?? ''
};

    // 데이터 행이 아니라 시트 하단의 요약/빈 줄(예: '치료횟수') 같은 경우 걸러내기
    const maybeName = toStr(obj['이름']).trim();
    const maybeType = toStr(obj['치료타입']).trim();
    const maybePart = toStr(obj['치료부위']).trim();
    const maybeNo = toStr(obj['번호']).trim();

    if(!maybeNo && !maybeName && !maybeType && !maybePart) continue;

    out.push(obj);
  }
  return out;
}

// -----------------------------
    // 2) 파일 로드 -> 정규화 -> 환자 집계
    // -----------------------------
    function handleFile(file){
      if(!file) return;
      document.getElementById('statusText').textContent = `로드됨: ${file.name}`;

      const r = new FileReader();
      r.onload = e => {
        const wb = XLSX.read(new Uint8Array(e.target.result), {type:'array'});
        rawRows = extractRowsFromWorkbook(wb);
        const picked = pickBestSheetName(wb);
        if(picked) document.getElementById('statusText').textContent = `로드됨: ${file.name} · 시트: ${picked}`;
        buildData();
        selPVal = -1;
        buildPriceButtons();
        buildExcludeButtons();
        renderAll();
        };
      r.readAsArrayBuffer(file);
    }

    function buildData(){
      // 1) 키 정리
      const cleaned = rawRows.map(row => {
        const out = {};
        Object.keys(row||{}).forEach(k => out[normKey(k)] = row[k]);
        return out;
      });

      // 2) 치료사/환자 컨텍스트 ffill
      let ctx = { therapist:'', name:'', chart:'', sexAge:'', newFlag:'', visitDt:null, typeRaw:'', round:'', room:'' };

      const recs = [];
      for(const r of cleaned){
        const no = toStr(r['번호']).trim();
        if(no && no.includes('치료사') && no.includes('환자')){
          // ex) "김기목 치료사 환자 현황"
          const t = no.split('치료사')[0].trim();
          ctx.therapist = t || ctx.therapist;
          ctx.name = '';
          ctx.chart = '';
          ctx.sexAge = '';
          ctx.newFlag = '';
          ctx.visitDt = null;
          ctx.typeRaw = '';
          ctx.round = '';
          ctx.room = '';
          continue; // 헤더 행 제외
        }

        const name = toStr(r['이름']).trim();
        if(name){
          ctx.name = name;
          const c = toStr(r['환자 차트']).trim();
          if(c) ctx.chart = c;
          const sa = toStr(r['성별/연령']).trim();
          if(sa) ctx.sexAge = sa;
          const nf = toStr(r['신/재']).trim();
          if(nf) ctx.newFlag = nf;
        }

        // 실제 데이터가 거의 없는 빈 행은 스킵
        const maybeData = ctx.name || toStr(r['치료부위']).trim() || toStr(r['치료타입']).trim();
        if(!maybeData) continue;

        let visitDt = parseVisitDate(r['방문일']);
        if(visitDt) ctx.visitDt = visitDt;
        else visitDt = ctx.visitDt || null;
        const vk = dateKey(visitDt);

        let rt = toStr(r['치료타입']).trim();
        if(rt) ctx.typeRaw = rt;
        else rt = ctx.typeRaw || '';

        let round = toStr(r['치료차수']).trim();
        if(round) ctx.round = round;
        else round = ctx.round || '';

        let room = toStr(r['진료실']).trim();
        if(room) ctx.room = room;
        else room = ctx.room || '';

        const amt = moneyOrNull(r['금액']);

        const sexAge = toStr(r['성별/연령']).trim() || ctx.sexAge;
        const newFlag = toStr(r['신/재']).trim() || ctx.newFlag;

        const chart = toStr(r['환자 차트']).trim() || ctx.chart;

        const reserveRaw = toStr(r['예약']).trim();
        const reserveVal = (()=>{
          const v = reserveRaw ? reserveRaw.toUpperCase() : '';
          return (v==='O' || v==='X') ? v : '';
        })();

        recs.push({
          therapist: ctx.therapist || '미상',
          name: ctx.name,
          chart: chart,
          key: (chart ? (chart+'|'+ctx.name) : ctx.name),
          sexAge: sexAge,
          gender: parseGender(sexAge),
          ageBucket: parseAgeBucket(sexAge),
          newFlag: newFlag,
          part: toStr(r['치료부위']).trim() || '(미기입)',
          typeRaw: rt,
          type: normalizeType(rt),
          amount: amt,
          visitKey: vk,
          visitDate: visitDt,
          reserve: reserveVal,
          room: room,
          round: round
        });
      }

      records = normalizeRecords(recs);

      patientsAll = computePatientsFrom(records);

      // 치료 금액(첫 충격파 치료금액) 후보는 데이터에 따라 유동적입니다.
      amountListAll = Array.from(new Set(
        patientsAll.filter(p=>p.isNew)
          .map(p=>p.entryPrice)
          .filter(v=>isFinite(v) && v>0)
      )).sort((a,b)=>a-b);

      exclAmtSet = new Set();
      rebuildDerived();
}

    function computePatientsFrom(sourceRecords){
      const byP = new Map();
      for(const row of (sourceRecords||[])){
        if(!row.key) continue;
        if(!byP.has(row.key)) byP.set(row.key, []);
        byP.get(row.key).push(row);
      }

      const pats = [];
      for(const [pkey, rows] of byP.entries()){
        const any = rows[0];
        const isNew = rows.some(r => toStr(r.newFlag).includes('신환'));
        const hasShock = rows.some(r => isShock(r.typeRaw));
        const hasInj = rows.some(r => isInjection(r.typeRaw));
        const hasMan = rows.some(r => isManual(r.typeRaw));

        // ✅ 엑셀 기준 신환 귀속:
        // - 치료사: '신환'으로 표시된 행의 치료사(섹션)로 귀속 (없으면 첫 행 치료사)
        // - 기준 방문일/금액: '신환' 행의 방문일/금액을 우선 (없으면 기존 로직)
        const newRows = rows.filter(r => toStr(r.newFlag).includes('신환'));
        const newTherapist = (newRows.map(r=>toStr(r.therapist).trim()).find(v=>v) || '').trim();
        const newVisitKey = (() => {
          const ks = newRows.map(r=>r.visitKey).filter(Boolean).sort((a,b)=>a-b);
          return ks.length ? ks[0] : null;
        })();

        const visitKeysAllRaw = new Set(rows.map(r=>r.visitKey).filter(Boolean));
        const shockVisitKeysRaw = new Set(rows.filter(r=>isShock(r.typeRaw)).map(r=>r.visitKey).filter(Boolean));

        // '충격파'가 명시되지 않은 행(예: 주사치료만 표기)도 엑셀에는 포함될 수 있으므로,
        // 충격파 방문키가 없으면 전체 방문키를 치료(방문) 기준으로 사용합니다.
        const primaryVisitKeysRaw = (shockVisitKeysRaw.size ? shockVisitKeysRaw : visitKeysAllRaw);

        const allKeysRaw = Array.from(visitKeysAllRaw).sort((a,b)=>a-b);
        const prKeysRaw  = Array.from(primaryVisitKeysRaw).sort((a,b)=>a-b);

        // 신환 기준 시작일(신환 행의 방문일이 있으면 그날부터) — 없으면 기존 첫 방문일
        const baseKey = (newVisitKey !== null) ? newVisitKey : (prKeysRaw.length ? prKeysRaw[0] : (allKeysRaw.length ? allKeysRaw[0] : null));

        const allKeys = (baseKey===null) ? allKeysRaw : allKeysRaw.filter(k=>k>=baseKey);
        const prKeys  = (baseKey===null) ? prKeysRaw  : prKeysRaw.filter(k=>k>=baseKey);

        const visitKeysAll = new Set(allKeys);
        const primaryVisitKeys = new Set(prKeys);

        const firstAll = allKeys.length ? allKeys[0] : null;
        const firstPrimary = prKeys.length ? prKeys[0] : firstAll;

        // 진입 금액(= 신환 첫 치료 금액)도 '신환' 행의 방문일을 우선
        const entryKey = (newVisitKey !== null) ? newVisitKey : firstPrimary;

        let entry = null;
        if(entryKey !== null){
          const shRows = rows.filter(r => r.visitKey===entryKey && isShock(r.typeRaw));
          const am1 = shRows.map(r=>r.amount).filter(v=>isFinite(v));
          entry = am1.length ? Math.max(...am1) : null;
          if(entry===null){
            const allRows = rows.filter(r => r.visitKey===entryKey);
            const am2 = allRows.map(r=>r.amount).filter(v=>isFinite(v));
            entry = am2.length ? Math.max(...am2) : null;
          }
        }

        let entryRoom = '';
        if(entryKey !== null){
          entryRoom = rows.filter(r=>r.visitKey===entryKey).map(r=>toStr(r.room).trim()).find(v=>v) || '';
        }

        let daysTo2 = null;
        if(prKeys.length >= 2){
          daysTo2 = Math.max(0, Math.round((prKeys[1]-prKeys[0]) / 86400000));
        }

        pats.push({
          key: pkey,
          therapist: (newTherapist || any.therapist || '미상'),
          name: any.name,
          chart: any.chart,
          gender: any.gender,
          ageBucket: any.ageBucket,
          isNew: isNew,
          entryPrice: entry,
          entryRoom: entryRoom,
          visitCountAll: visitKeysAll.size,
          shockVisitCount: primaryVisitKeys.size,
          firstShockKey: firstPrimary,
          daysTo2: daysTo2,
          hasInjection: hasInj,
          hasManual: hasMan,
          rows: rows
        });
      }
      return pats;
    }

    function activePatients(){
  // 제외된 치료 금액(첫 충격파 치료금액)으로 시작한 신환은 분석에서 제외
  if(!exclAmtSet || !exclAmtSet.size) return patientsAll.slice();
  return patientsAll.filter(p => !(p.isNew && isFinite(p.entryPrice) && exclAmtSet.has(p.entryPrice)));
}

function rebuildDerived(){
  const act = activePatients();
  entryPriceList = Array.from(new Set(
    act.filter(p=>p.isNew)
      .map(p=>p.entryPrice)
      .filter(v=>isFinite(v) && v>0)
  )).sort((a,b)=>a-b);

  // 선택 금액이 더 이상 존재하지 않으면 '전체'로 복귀
  if(selPVal !== -1 && !entryPriceList.includes(selPVal)) selPVal = -1;
}


    // -----------------------------
    // 3) 필터 버튼
    // -----------------------------
function buildPriceButtons(){
      const box = document.getElementById('priceBtns');
      box.innerHTML = '';

      const mkBtn = (label, val) => {
        const b = document.createElement('button');
        b.className = 'price-btn sel-btn' + (selPVal===val ? ' active' : '');
        b.textContent = label;
        b.onclick = () => {
          selPVal = val;
          document.querySelectorAll('.sel-btn').forEach(x => x.classList.remove('active'));
          b.classList.add('active');
          renderAll();
        };
        return b;
      };

      box.appendChild(mkBtn('전체', -1));
      entryPriceList.forEach(v => box.appendChild(mkBtn(v.toLocaleString() + '원', v)));

      document.getElementById('filterArea').classList.remove('hidden');
    }

    function buildExcludeButtons(){
      const box = document.getElementById('excludeBtns');
      if(!box) return;
      box.innerHTML = '';

      const mkBtn = (label, val) => {
        const b = document.createElement('button');
        b.className = 'price-btn excl-btn' + (exclAmtSet.has(val) ? ' active' : '');
        b.textContent = label;
        b.onclick = () => {
          if(exclAmtSet.has(val)) exclAmtSet.delete(val);
          else exclAmtSet.add(val);

          rebuildDerived();
          buildPriceButtons();
          buildExcludeButtons();
          renderAll();
        };
        return b;
      };

      // 금액 후보(원 데이터 기준) + 현재 제외값 union
      const union = Array.from(new Set([...(amountListAll||[]), ...Array.from(exclAmtSet||[])]))
        .filter(v=>isFinite(v) && v>0)
        .sort((a,b)=>a-b);

      union.forEach(v => box.appendChild(mkBtn(v.toLocaleString() + '원', v)));

      // 초기화
      const clearBtn = document.createElement('button');
      clearBtn.className = 'price-btn excl-btn' + (exclAmtSet.size ? '' : ' active');
      clearBtn.textContent = '제외 초기화';
      clearBtn.onclick = () => {
        exclAmtSet = new Set();
        rebuildDerived();
        buildPriceButtons();
        buildExcludeButtons();
        renderAll();
      };
      box.appendChild(clearBtn);
    }


    // -----------------------------
    // 4) 렌더링 헬퍼
    // -----------------------------
    function setHtml(id, html){ const el = document.getElementById(id); if(el) el.innerHTML = html; }

    function renderKeyValueTable(tableId, rows){
      // rows: [{k, v}]
      const h = `<thead><tr><th style="width:180px;">항목</th><th>값</th></tr></thead><tbody>` +
        rows.map(r=>`<tr><td>${r.k}</td><td>${r.v}</td></tr>`).join('') +
        `</tbody>`;
      setHtml(tableId, h);
    }

    function renderSimpleTable(tableId, cols, rows){
      // cols: [{k:'field', l:'label', w?:number}]
      const thead = `<thead><tr>` + cols.map(c=>{
        const w = c.w ? ` style="width:${c.w}px"` : '';
        return `<th${w}>${c.l}</th>`;
      }).join('') + `</tr></thead>`;

      const tbody = `<tbody>` + (rows||[]).map(r=>{
        const cls = (r && r._rowClass) ? ` class="${r._rowClass}"` : '';
        return `<tr${cls}>` + cols.map(c=>{
          const v = (r && (r[c.k]!==null && r[c.k]!==undefined)) ? r[c.k] : '';
          return `<td>${v}</td>`;
        }).join('') + `</tr>`;
      }).join('') + `</tbody>`;

      setHtml(tableId, thead + tbody);
    }

    function renderFollowSummary(rows, elementId='followSummary13'){
      const el = document.getElementById(elementId);
      if(!el) return;

      const items = (rows||[]).filter(r=>{
        return r && r['치료사'] && r['치료사']!=='총 합계' && !(toStr(r['비고']).includes('표본 적음')) && (r._n||0) >= 5;
      }).map(r=>{
        const medTxt = (r._med===null || r._med===undefined) ? '-' : (Math.round(r._med)+'일');
        return {
          t: r['치료사'],
          a: r['연령대'],
          rec: r['권장 연락'],
          one: r._oneRate||0,
          r7: r._r7||0,
          med: medTxt,
          n: r._n||0,
          score: (r._score||0)
        };
      }).sort((a,b)=>b.score-a.score).slice(0,5);

      if(items.length===0){
        el.innerHTML = `<div class="title">재방문 관리 요약</div><div class="muted">표본이 부족해 요약을 만들 수 없습니다 (n≥5 기준).</div>`;
        return;
      }
      const li = items.map(x=>`<li><b>${x.t} / ${x.a}</b><div class="meta">${x.rec}</div><div class="meta">1회만 내원 ${fmtPct(x.one)} · 7일 내 재방문율 ${fmtPct(x.r7)} · 2회차 주기 ${x.med} · n=${fmtInt(x.n)}</div></li>`).join('');
      el.innerHTML = `<div class="title">재방문 관리 요약 (우선순위 Top ${items.length})</div><ol>${li}</ol>`;
    }


    function renderMatrix(tableId, rowLabels, colLabels, getVal){
      // Adds both row totals (right) and column totals (bottom)
      const head = `<thead><tr><th style="width:110px;">구분</th>` +
        colLabels.map(c=>`<th>${c}</th>`).join('') +
        `<th class="total-col">총 합계</th></tr></thead>`;

      const colTotals = new Array(colLabels.length).fill(0);
      let grand = 0;

      let body = `<tbody>`;
      rowLabels.forEach((rLabel, ri) => {
        let rowSum = 0;
        let cells = '';
        colLabels.forEach((cLabel, ci) => {
          const v = getVal(rLabel, cLabel) || 0;
          rowSum += v;
          colTotals[ci] += v;
          cells += `<td>${v}</td>`;
        });
        grand += rowSum;
        body += `<tr><td>${rLabel}</td>${cells}<td class="total-col">${rowSum}</td></tr>`;
      });

      // totals row
      body += `<tr class="total-row"><td>총 합계</td>` +
        colTotals.map(v=>`<td>${v}</td>`).join('') +
        `<td class="total-col">${grand}</td></tr>`;

      body += `</tbody>`;
      setHtml(tableId, head + body);
    }


    function renderMatrixAvg(tableId, rowLabels, colLabels, getStat){
      // rowLabels: rows, colLabels: cols
      // getStat(r,c) -> {sum:number, n:number}
      const head = `<thead><tr><th style="width:110px;">구분</th>` +
        colLabels.map(c=>`<th>${c}</th>`).join('') +
        `<th class="total-col">전체</th></tr></thead>`;

      const colSum = new Array(colLabels.length).fill(0);
      const colN   = new Array(colLabels.length).fill(0);
      let gSum = 0, gN = 0;

      let body = `<tbody>`;
      rowLabels.forEach(rLabel=>{
        let rSum = 0, rN = 0;
        let cells = '';
        colLabels.forEach((cLabel, ci)=>{
          const st = getStat(rLabel, cLabel) || {sum:0,n:0};
          const s = (st.sum||0), n = (st.n||0);
          rSum += s; rN += n;
          colSum[ci] += s; colN[ci] += n;

          if(n>0){
            const avg = s/n;
            cells += `<td><div>${avg.toFixed(1)}</div><div style="font-size:10px;color:var(--gray);">n=${n}</div></td>`;
          }else{
            cells += `<td>-</td>`;
          }
        });
        gSum += rSum; gN += rN;
        const rAvgCell = (rN>0)
          ? `<td class="total-col"><div>${(rSum/rN).toFixed(1)}</div><div style="font-size:10px;color:var(--gray);">n=${rN}</div></td>`
          : `<td class="total-col">-</td>`;
        body += `<tr><td>${rLabel}</td>${cells}${rAvgCell}</tr>`;
      });

      // totals row (가중 평균)
      const totCells = colLabels.map((c,ci)=>{
        const n = colN[ci], s = colSum[ci];
        return n>0
          ? `<td><div>${(s/n).toFixed(1)}</div><div style="font-size:10px;color:var(--gray);">n=${n}</div></td>`
          : `<td>-</td>`;
      }).join('');

      const gCell = (gN>0)
        ? `<td class="total-col"><div>${(gSum/gN).toFixed(1)}</div><div style="font-size:10px;color:var(--gray);">n=${gN}</div></td>`
        : `<td class="total-col">-</td>`;

      body += `<tr class="total-row"><td>총 합계</td>${totCells}${gCell}</tr>`;
      body += `</tbody>`;
      setHtml(tableId, head + body);
    }


    function cohortPatients(){
      return activePatients().filter(p => p.isNew && (selPVal===-1 || p.entryPrice===selPVal));
    }

    // -----------------------------
    // 5) 메인 렌더
    // -----------------------------
    function renderAll(){
      document.getElementById('dashArea').classList.remove('hidden');
      document.getElementById('mainContent').classList.remove('hidden');

      const cohort = cohortPatients();
      const hasAgeUnknown = cohort.some(p => (p.ageBucket||'') === '미상');
      const ageCols = hasAgeUnknown ? AGE_BUCKETS : AGE_BUCKETS.filter(a => a !== '미상');
      const hasGenderUnknown = cohort.some(p => (p.gender||'') === '미상');
      const genCols = hasGenderUnknown ? GENDERS : GENDERS.filter(g => g !== '미상');

      
      // Dashboard
      const n = cohort.length;
      const convN = cohort.filter(p => p.shockVisitCount >= 2).length;
      const r3N = cohort.filter(p => p.shockVisitCount >= 3).length;
      const comboN = cohort.filter(p => p.hasInjection).length;

      const shockCounts = cohort.map(p=>p.shockVisitCount);
      const avgV = shockCounts.length ? (shockCounts.reduce((a,b)=>a+b,0)/shockCounts.length) : 0;
      const medV = median(shockCounts);
      const modeV = modeInfo(shockCounts);

      const r7N  = cohort.filter(p => (p.daysTo2 !== null && p.daysTo2 <= 7)).length;
      const r14N = cohort.filter(p => (p.daysTo2 !== null && p.daysTo2 <= 14)).length;

      const selLabel = (selPVal===-1 ? '치료 금액: 전체' : ('치료 금액: ' + selPVal.toLocaleString() + '원'));
      const exclLabel = (exclAmtSet && exclAmtSet.size)
        ? (' · 제외: ' + Array.from(exclAmtSet).sort((a,b)=>a-b).map(v=>v.toLocaleString()+'원').join(', '))
        : '';

      document.getElementById('v-count').textContent = fmtInt(n);
      document.getElementById('v-count-sub').textContent = selLabel + exclLabel;

      document.getElementById('v-conv').textContent = n ? fmtPct(convN/n) : '0%';
      document.getElementById('v-conv-sub').textContent = n ? `${convN}/${n}` : '0/0';

      document.getElementById('v-ret').textContent = n ? fmtPct(r3N/n) : '0%';
      document.getElementById('v-ret-sub').textContent = n ? `${r3N}/${n}` : '0/0';

      document.getElementById('v-combo').textContent = n ? fmtPct(comboN/n) : '0%';
      document.getElementById('v-combo-sub').textContent = n ? `${comboN}/${n}` : '0/0';

      document.getElementById('v-avgV').textContent = avgV.toFixed(1);
      document.getElementById('v-medV').textContent = String(medV);

      const modeLabel = modeV.modes.length ? modeV.modes.join(', ') : '-';
      const modeSub = modeV.maxFreq ? ((modeV.modes.length>1 ? '공동 최빈 · ' : '') + `최대 빈도: ${modeV.maxFreq}명`) : '';
      document.getElementById('v-modeV').textContent = modeLabel;
      document.getElementById('v-modeV-sub').textContent = modeSub;

      document.getElementById('v-r7').textContent = n ? fmtPct(r7N/n) : '0%';
      document.getElementById('v-r7-sub').textContent = n ? `${r7N}/${n}` : '0/0';

      document.getElementById('v-r14').textContent = n ? fmtPct(r14N/n) : '0%';
      document.getElementById('v-r14-sub').textContent = n ? `${r14N}/${n}` : '0/0';

// 표 1: 진료실별 치료 횟수 (도수치료 row 기준) - 연령대 포함
      const roomAge = new Map(); // key: room||age => count
      cohort.forEach(p => {
        const byVisit = new Map();
        p.rows.filter(r => isShock(r.typeRaw)).forEach(r => {
          const k = (r.visitKey===null || r.visitKey===undefined) ? 'noDate' : String(r.visitKey);
          if(!byVisit.has(k)) byVisit.set(k, []);
          byVisit.get(k).push(r);
        });

        for(const rows of byVisit.values()){
          const age = (rows.find(x=>x.ageBucket)?.ageBucket) || p.ageBucket || '미상';
          const room = rows.map(x=>toStr(x.room).trim()).find(v=>v) || toStr(p.entryRoom).trim() || '미상';
          const kk = room + '||' + age;
          roomAge.set(kk, (roomAge.get(kk)||0) + 1);
        }
      });

      const ROOM_LABELS = Array.from(new Set(Array.from(roomAge.keys()).map(k=>k.split('||')[0])))
        .filter(v=>v)
        .sort((a,b)=>a.localeCompare(b,'ko'));
      const ROOM_ROWS = ROOM_LABELS.length ? ROOM_LABELS : ['미상'];
      renderMatrix('table1', ROOM_ROWS, ageCols, (room, a) => roomAge.get(room + '||' + a) || 0);



      
// 표 2: 요약 핵심지표
const injRate = n ? comboN/n : 0;
const selTxt = (selPVal===-1 ? '전체' : (selPVal.toLocaleString()+'원'));
const exclTxt = (exclAmtSet && exclAmtSet.size)
  ? (' / 제외: ' + Array.from(exclAmtSet).sort((a,b)=>a-b).map(v=>v.toLocaleString()+'원').join(', '))
  : '';

// 치료 횟수(정확히 n회) 분포: 1~4회는 '딱 n회', 5회 이상은 '5회+'
const c1 = shockCounts.filter(v=>v===1).length;
const c2 = shockCounts.filter(v=>v===2).length;
const c3 = shockCounts.filter(v=>v===3).length;
const c4 = shockCounts.filter(v=>v===4).length;
const c5p = shockCounts.filter(v=>v>=5).length;

renderKeyValueTable('table2', [
  {k:'신환 수(치료 금액)', v: `${fmtInt(n)}명 / ${selTxt}${exclTxt}`},
  {k:'1회만(%)', v: n ? `${fmtPct(c1/n)} (${fmtInt(c1)}명)` : '0% (0명)'},
  {k:'2회만(%)', v: n ? `${fmtPct(c2/n)} (${fmtInt(c2)}명)` : '0% (0명)'},
  {k:'3회만(%)', v: n ? `${fmtPct(c3/n)} (${fmtInt(c3)}명)` : '0% (0명)'},
  {k:'4회만(%)', v: n ? `${fmtPct(c4/n)} (${fmtInt(c4)}명)` : '0% (0명)'},
  {k:'5회 이상(%)', v: n ? `${fmtPct(c5p/n)} (${fmtInt(c5p)}명)` : '0% (0명)'},
  {k:'2회 이상 치료 비율(%)', v: n ? fmtPct(convN/n) : '0%'},
  {k:'3회 이상 치료 비율(%)', v: n ? fmtPct(r3N/n) : '0%'},
  {k:'주사치료 병행 비율', v: n ? fmtPct(injRate) : '0%'},
  {k:'평균 치료 횟수(' + '도수' + ')', v: avgV.toFixed(2)},
  {k:'중간값 치료 횟수(' + '도수' + ')', v: String(medV)},
  {k:'최빈 치료 횟수(' + '도수' + ')', v: (modeV.modes.length ? modeV.modes.join(', ') : '-')},
  {k:'7일 내 재방문율', v: n ? fmtPct(r7N/n) : '0%'},
  {k:'14일 내 재방문율', v: n ? fmtPct(r14N/n) : '0%'}
]);

// 표 3: 연령대별 (신환 수 / 재방문 / 평균 치료 횟수)
      const byAge = new Map(ageCols.map(a=>[a, {patients:0, shockDays:0, revisitPatients:0, revisitCount:0}]));
      cohort.forEach(p => {
        const bucket = ageCols.includes(p.ageBucket) ? p.ageBucket : (ageCols.includes('미상') ? '미상' : ageCols[0]);
        const o = byAge.get(bucket);
        o.patients += 1;
        o.shockDays += p.shockVisitCount;                  // 치료일 수 합(=치료 횟수 합)
        if(p.shockVisitCount >= 2) o.revisitPatients += 1; // 2회 이상 재방문한 사람 수
        o.revisitCount += Math.max(0, p.shockVisitCount - 1); // 재방문 횟수(초진 1회를 제외)
      });

      const t3 = ageCols.map(a=>{
        const o = byAge.get(a) || {patients:0, shockDays:0, revisitPatients:0, revisitCount:0};
        return {
          '연령대': a,
          '신환 수': o.patients,
          '재방문율': o.patients ? fmtPct(o.revisitPatients/o.patients) : '0%',
          '재방문 횟수': o.revisitCount,
          '평균 치료 횟수': o.patients ? (o.shockDays/o.patients).toFixed(2) : '0.00'
        };
      });

      // 합계(전체)
      const totalRevisitCount = shockCounts.reduce((a,c)=>a + Math.max(0, c-1), 0);
      t3.push({
        _rowClass: 'total-row',
        '연령대': '총 합계',
        '신환 수': n,
        '재방문율': n ? fmtPct(convN/n) : '0%',
        '재방문 횟수': totalRevisitCount,
        '평균 치료 횟수': n ? (shockCounts.reduce((a,c)=>a+c,0)/n).toFixed(2) : '0.00'
      });

      renderSimpleTable('table3',
        [{k:'연령대',l:'연령대',w:90},
         {k:'신환 수',l:'신환 수'},
         {k:'재방문율',l:'재방문율(2회 이상)'},
         {k:'재방문 횟수',l:'재방문 횟수'},
         {k:'평균 치료 횟수',l:'평균 치료 횟수'}],
        t3
      );

      // 표 4: 연령대 x 성별 (환자수)
      const sexMat = new Map();
      ageCols.forEach(a=>{
        const m = new Map(); genCols.forEach(g=>m.set(g,0));
        sexMat.set(a,m);
      });
      cohort.forEach(p=>{
        const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        const g = genCols.includes(p.gender) ? p.gender : '미상';
        sexMat.get(a).set(g, sexMat.get(a).get(g) + 1);
      });
      renderMatrix('table4', ageCols, genCols, (age, gen)=> (sexMat.get(age)?.get(gen)) || 0);

      // 표 5: 충격파 방문 횟수 분포 (방문 횟수 x 연령대) - 1~7회 이상까지 표시
const visitBins = ['1회','2회','3회','4회','5회','6회','7회 이상'];
const keepMat = new Map();
visitBins.forEach(b=>{
  const m = new Map(); ageCols.forEach(a=>m.set(a,0));
  keepMat.set(b,m);
});
cohort.forEach(p=>{
  const c = p.shockVisitCount;
  const b = (c>=7) ? '7회 이상' : (c + '회');
  if(!keepMat.has(b)) return;
  const age = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
  keepMat.get(b).set(age, keepMat.get(b).get(age) + 1);
});
renderMatrix('table5', visitBins, ageCols, (bin, age)=> (keepMat.get(bin)?.get(age)) || 0);


      // 표 6: 방문회차 인원 분포 (연령대 x 회차)
      const rounds = ['1회','2회','3회','4회','5회','6회 이상'];
      const distMat = new Map();
      ageCols.forEach(a=>{
        const m = new Map(); rounds.forEach(r=>m.set(r,0));
        distMat.set(a,m);
      });
      cohort.forEach(p=>{
        const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        const c = p.shockVisitCount;
        const r = (c>=6) ? '6회 이상' : (c + '회');
        distMat.get(a).set(r, distMat.get(a).get(r) + 1);
      });
      renderMatrix('table6', ageCols, rounds, (age, round)=> (distMat.get(age)?.get(round)) || 0);

      // 표 7: 치료 금액 구간별 핵심지표
      const actPatients = activePatients();
      const priceSet = Array.from(new Set(
        actPatients.filter(p=>p.isNew)
          .map(p=>p.entryPrice)
          .filter(v=>isFinite(v) && v>0)
      )).sort((a,b)=>a-b);

      const t7 = [];
      let totN = 0, totC2 = 0, totC3 = 0, totInj = 0, totShock = 0;

      priceSet.forEach(price=>{
        const ps = actPatients.filter(p=>p.isNew && p.entryPrice===price);
        const n0 = ps.length;
        const c2 = ps.filter(p=>p.shockVisitCount>=2).length;
        const c3 = ps.filter(p=>p.shockVisitCount>=3).length;
        const inj = ps.filter(p=>p.hasInjection).length;
        const shockSum = ps.reduce((a,p)=>a+p.shockVisitCount,0);
        const avgT = n0 ? (shockSum/n0) : 0;

        totN += n0; totC2 += c2; totC3 += c3; totInj += inj; totShock += shockSum;

        t7.push({
          '치료금액': price.toLocaleString()+'원',
          '신환수': n0,
          '2회차전환': n0 ? fmtPct(c2/n0) : '0%',
          '3회유지': n0 ? fmtPct(c3/n0) : '0%',
          '주사병행': n0 ? fmtPct(inj/n0) : '0%',
          '평균치료': n0 ? avgT.toFixed(2) : '0.00'
        });
      });

      if(priceSet.length){
        t7.push({
          _rowClass: 'total-row',
          '치료금액': '총 합계',
          '신환수': totN,
          '2회차전환': totN ? fmtPct(totC2/totN) : '0%',
          '3회유지': totN ? fmtPct(totC3/totN) : '0%',
          '주사병행': totN ? fmtPct(totInj/totN) : '0%',
          '평균치료': totN ? (totShock/totN).toFixed(2) : '0.00'
        });
      }

      renderSimpleTable('table7',
        [{k:'치료금액',l:'치료 금액',w:110},{k:'신환수',l:'신환수'},
         {k:'2회차전환',l:'2회차 전환'},{k:'3회유지',l:'3회 유지'},
         {k:'주사병행',l:'주사치료 병행'},{k:'평균치료',l:'평균 치료 횟수'}],
        t7
      );

      // 표 8: 치료사별 핵심지표
      const therapists = Array.from(new Set(cohort.map(p=>p.therapist))).sort((a,b)=>a.localeCompare(b));
      const t8 = [];

      therapists.forEach(t=>{
        const ps = cohort.filter(p=>p.therapist===t);
        const n0 = ps.length;
        const c2 = ps.filter(p=>p.shockVisitCount>=2).length;
        const c3 = ps.filter(p=>p.shockVisitCount>=3).length;
        const inj = ps.filter(p=>p.hasInjection).length;
        const shockSum = ps.reduce((a,p)=>a+p.shockVisitCount,0);
        const avgt = n0 ? shockSum/n0 : 0;

        t8.push({
          '치료사': t,
          '신환수': n0,
          '2회차전환': n0 ? fmtPct(c2/n0) : '0%',
          '3회유지': n0 ? fmtPct(c3/n0) : '0%',
          '주사병행': n0 ? fmtPct(inj/n0) : '0%',
          '평균치료': n0 ? avgt.toFixed(2) : '0.00'
        });
      });

      t8.push({
        _rowClass: 'total-row',
        '치료사': '총 합계',
        '신환수': n,
        '2회차전환': n ? fmtPct(convN/n) : '0%',
        '3회유지': n ? fmtPct(r3N/n) : '0%',
        '주사병행': n ? fmtPct(comboN/n) : '0%',
        '평균치료': n ? avgV.toFixed(2) : '0.00'
      });

      renderSimpleTable('table8',
        [{k:'치료사',l:'치료사',w:90},{k:'신환수',l:'신환수'},
         {k:'2회차전환',l:'2회차 전환'},{k:'3회유지',l:'3회 유지'},{k:'주사병행',l:'주사치료 병행'},
         {k:'평균치료',l:'평균 치료 횟수'}],
        t8
      );


      // 표 8-1: 도수치료 치료사별 신환/재진 예약 비율(O/X) (방문 단위)
      const cohortKeySet = new Set(cohort.map(p=>p.key));
      const firstShockMap = new Map(cohort.map(p=>[p.key, p.firstShockKey]));

      // 방문(환자+방문일+치료타입+회차+치료사) 단위로 예약값을 1개로 만든다.
      const visitAgg = new Map();
      for(const r of records){
if(!cohortKeySet.has(r.key)) continue;
        const vid = [r.key, r.therapist||'미상', String(r.visitKey||'')].join('||');
        if(!visitAgg.has(vid)){
          visitAgg.set(vid, {pkey:r.key, therapist:(r.therapist||'미상'), visitKey:r.visitKey, reserve:''});
        }
        const a = visitAgg.get(vid);
        const rv = toStr(r.reserve).trim().toUpperCase();
        if(rv==='O') a.reserve = 'O';
        else if(rv==='X' && a.reserve!=='O') a.reserve = 'X';
      }

      const byTher = new Map();
      const ensureTher = (t)=>{
        if(!byTher.has(t)) byTher.set(t, {t, nO:0, nX:0, nM:0, rO:0, rX:0, rM:0});
        return byTher.get(t);
      };

      for(const v of visitAgg.values()){
        const first = firstShockMap.get(v.pkey);
        const isNewVisit = (first !== null && first !== undefined && v.visitKey === first);
        const st = ensureTher(v.therapist);
        const bucket = isNewVisit ? 'n' : 'r';
        if(v.reserve==='O') st[bucket+'O']++;
        else if(v.reserve==='X') st[bucket+'X']++;
        else st[bucket+'M']++;
      }

      const therRows = Array.from(byTher.values()).sort((a,b)=>a.t.localeCompare(b.t,'ko'));
      const t8r = therRows.map(x=>{
        const nDen = x.nO + x.nX;
        const rDen = x.rO + x.rX;
        return {
          '치료사': x.t,
          '신환 O': x.nO,
          '신환 X': x.nX,
          '신환 예약 비율': nDen ? fmtPct(x.nO/nDen) : '0%',
          '재진 O': x.rO,
          '재진 X': x.rX,
          '재진 예약 비율': rDen ? fmtPct(x.rO/rDen) : '0%',
          '미기입': x.nM + x.rM
        };
      });

      // 총 합계 행
      const tot8r = therRows.reduce((acc,x)=>{
        acc.nO += x.nO; acc.nX += x.nX; acc.nM += x.nM;
        acc.rO += x.rO; acc.rX += x.rX; acc.rM += x.rM;
        return acc;
      }, {nO:0,nX:0,nM:0,rO:0,rX:0,rM:0});

      const nDenAll = tot8r.nO + tot8r.nX;
      const rDenAll = tot8r.rO + tot8r.rX;
      t8r.push({
        _rowClass: 'total-row',
        '치료사': '총 합계',
        '신환 O': tot8r.nO,
        '신환 X': tot8r.nX,
        '신환 예약 비율': nDenAll ? fmtPct(tot8r.nO/nDenAll) : '0%',
        '재진 O': tot8r.rO,
        '재진 X': tot8r.rX,
        '재진 예약 비율': rDenAll ? fmtPct(tot8r.rO/rDenAll) : '0%',
        '미기입': tot8r.nM + tot8r.rM
      });

      renderSimpleTable('table8r',
        [{k:'치료사',l:'치료사',w:90},
         {k:'신환 O',l:'신환 O'},{k:'신환 X',l:'신환 X'},{k:'신환 예약 비율',l:'신환 예약 비율'},
         {k:'재진 O',l:'재진 O'},{k:'재진 X',l:'재진 X'},{k:'재진 예약 비율',l:'재진 예약 비율'},
         {k:'미기입',l:'미기입'}],
        t8r
      );

      // 표 9: 재방문 주기(첫 도수치료 → 2회차)
      const speedBinsAll = ['0-7일','8-14일','15-30일','31-60일','61일 이상','1회만 내원'];
      const spMat = new Map();
      speedBinsAll.forEach(b=>{
        const m = new Map(); ageCols.forEach(a=>m.set(a,0));
        spMat.set(b,m);
      });

      cohort.forEach(p=>{
        const age = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        let b = '1회만 내원'; // 2회차가 없으면 1회만 내원으로 분류
        if(p.daysTo2 !== null){
          const d = p.daysTo2;
          if(d <= 7) b = '0-7일';
          else if(d <= 14) b = '8-14일';
          else if(d <= 30) b = '15-30일';
          else if(d <= 60) b = '31-60일';
          else b = '61일 이상';
        }
        spMat.get(b).set(age, spMat.get(b).get(age) + 1);
      });

      // 데이터가 없는 구간(예: 30일 이내 데이터면 31-60일/61일 이상)을 자동으로 숨김
      const speedBins = speedBinsAll.filter(bin=>{
        let total = 0;
        ageCols.forEach(a=> total += spMat.get(bin)?.get(a) || 0);
        return total > 0;
      });

      renderMatrix('table9', speedBins, ageCols, (bin, age)=> (spMat.get(bin)?.get(age)) || 0);


      // 표 10: 진료실별 핵심지표 (신환 첫 치료 기준)
      const roomKey = (p)=>{ const r = toStr(p.entryRoom).trim(); return r ? r : '미상'; };
      const rooms = Array.from(new Set(cohort.map(roomKey))).sort((a,b)=>a.localeCompare(b,'ko'));
      const t10 = [];
      rooms.forEach(rm=>{
        const ps = cohort.filter(p=>roomKey(p)===rm);
        const nn = ps.length;
        const c2 = ps.filter(p=>p.shockVisitCount>=2).length;
        const c3 = ps.filter(p=>p.shockVisitCount>=3).length;
        const inj = ps.filter(p=>p.hasInjection).length;
        const sumV = ps.reduce((a,p)=>a+p.shockVisitCount,0);
        const r7 = ps.filter(p => (p.daysTo2 !== null && p.daysTo2 <= 7)).length;
        const r14 = ps.filter(p => (p.daysTo2 !== null && p.daysTo2 <= 14)).length;
        t10.push({
          '진료실': rm,
          '신환 수': fmtInt(nn),
          '2회 이상 치료 비율': nn?fmtPct(c2/nn):'0%',
          '3회 이상 치료 비율': nn?fmtPct(c3/nn):'0%',
          '주사 병행 비율': nn?fmtPct(inj/nn):'0%',
          '평균 치료 횟수': nn?(sumV/nn).toFixed(1):'0.0',
          '7일 내 재방문율': nn?fmtPct(r7/nn):'0%',
          '14일 내 재방문율': nn?fmtPct(r14/nn):'0%',
        });
      });
      // 총 합계
      t10.push({
        '진료실':'총 합계',
        '신환 수': fmtInt(n),
        '2회 이상 치료 비율': n?fmtPct(convN/n):'0%',
        '3회 이상 치료 비율': n?fmtPct(r3N/n):'0%',
        '주사 병행 비율': n?fmtPct(comboN/n):'0%',
        '평균 치료 횟수': avgV.toFixed(1),
        '7일 내 재방문율': n?fmtPct(r7N/n):'0%',
        '14일 내 재방문율': n?fmtPct(r14N/n):'0%',
        _rowClass:'total-row'
      });

      renderSimpleTable('table10',
        [{k:'진료실',l:'진료실',w:90},
         {k:'신환 수',l:'신환 수'},
         {k:'2회 이상 치료 비율',l:'2회 이상 치료 비율'},
         {k:'3회 이상 치료 비율',l:'3회 이상 치료 비율'},
         {k:'주사 병행 비율',l:'주사 병행 비율'},
         {k:'평균 치료 횟수',l:'평균 치료 횟수'},
         {k:'7일 내 재방문율',l:'7일 내 재방문율'},
         {k:'14일 내 재방문율',l:'14일 내 재방문율'}],
        t10
      );

      // 표 11: 치료사별·연령대별 평균 치료 횟수
      const ageSet = new Set(ageCols);
      const getTAStat = (t,a)=>{
        const ps = cohort.filter(p => p.therapist===t && ((p.ageBucket||'미상')===a));
        const s = ps.reduce((x,p)=>x+p.shockVisitCount,0);
        return {sum:s, n:ps.length};
      };
      renderMatrixAvg('table11', therapists, ageCols, getTAStat);

      // 표 12: 치료사별·연령대별 치료 횟수 분포 (Follow-up 설계용)
      // 표 12: 치료사별·연령대별 치료 횟수 분포 (치료사 1명당 표 1개)
      const bins = ['1회','2회','3회','4회','5회 이상'];
      const binOf = (c)=>{
        if(c<=1) return '1회';
        if(c===2) return '2회';
        if(c===3) return '3회';
        if(c===4) return '4회';
        return '5회 이상';
      };

      const usedAges = new Set();
      const tMap = new Map(); // therapist -> {therapist,totalN,m:Map}
      cohort.forEach(p=>{
        const t = p.therapist || '미상';
        const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        usedAges.add(a);
        const b = binOf(p.shockVisitCount || 0);
        if(!tMap.has(t)) tMap.set(t, {therapist:t, totalN:0, m:new Map()});
        const o = tMap.get(t);
        o.totalN += 1;
        const k = b + '||' + a;
        o.m.set(k, (o.m.get(k)||0) + 1);
      });

      const ageCols12 = AGE_BUCKETS.filter(a=>usedAges.has(a));

      function buildTherapistDistTable(o){
        const t = o.therapist || '미상';
        let html = `<div class="miniCard">`;
        html += `<div class="miniTitle"><span>${t}</span><span class="miniSub">신환 ${fmtInt(o.totalN)}명</span></div>`;
        html += `<div class="table-scroll"><table class="mini-table"><thead><tr><th style="width:74px">치료 횟수</th>`;
        ageCols12.forEach(a=>{ html += `<th>${a}</th>`; });
        html += `<th style="width:72px">합계</th></tr></thead><tbody>`;

        bins.forEach(b=>{
          let rowSum = 0;
          html += `<tr><td><b>${b}</b></td>`;
          ageCols12.forEach(a=>{
            const v = o.m.get(b+'||'+a) || 0;
            rowSum += v;
            html += `<td>${v?fmtInt(v):''}</td>`;
          });
          html += `<td><b>${rowSum?fmtInt(rowSum):''}</b></td></tr>`;
        });

        // totals row
        html += `<tr class="total-row"><td><b>합계</b></td>`;
        let grand = 0;
        ageCols12.forEach(a=>{
          let colSum = 0;
          bins.forEach(b=>{ colSum += (o.m.get(b+'||'+a)||0); });
          grand += colSum;
          html += `<td><b>${colSum?fmtInt(colSum):''}</b></td>`;
        });
        html += `<td><b>${grand?fmtInt(grand):''}</b></td></tr>`;

        html += `</tbody></table></div></div>`;
        return html;
      }

      const therapistList = Array.from(tMap.values()).sort((a,b)=>toStr(a.therapist).localeCompare(toStr(b.therapist),'ko'));
      if(therapistList.length===0){
        setHtml('table12', '<div class="muted">표시할 데이터가 없습니다.</div>');
      }else{
        setHtml('table12', `<div class="subtablesGrid">` + therapistList.map(buildTherapistDistTable).join('') + `</div>`);
      }

      
// 표 13: 치료사별·연령대별 재방문 안내 연락 시점 및 예약 확인(권장)
const followMap = new Map();
cohort.forEach(p=>{
  const t = toStr(p.therapist).trim() || '미상';
  const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
  const k = t + '||' + a;
  if(!followMap.has(k)){
    followMap.set(k, {치료사:t, 연령대:a, n:0, one:0, r7:0, r14:0, days:[]});
  }
  const o = followMap.get(k);
  o.n += 1;
  if(p.shockVisitCount === 1) o.one += 1;
  if(p.daysTo2 !== null && isFinite(p.daysTo2)){
    o.days.push(p.daysTo2);
    if(p.daysTo2 <= 7) o.r7 += 1;
    if(p.daysTo2 <= 14) o.r14 += 1;
  }
});

const recFor = (n0, oneRate, r7Rate) => {
  if(n0 < 5){
    return {rec:'표본 적음(참고)', note:'표본 적음'};
  }
  if(oneRate >= 0.60 || r7Rate < 0.25){
    return {rec:'첫 치료 후 48시간 안에 예약 확인 + 3일째/7일째 재방문 안내', note:''};
  }
  if(r7Rate < 0.40){
    return {rec:'첫 치료 후 72시간 안에 예약 확인 + 7일째 재방문 안내', note:''};
  }
  return {rec:'미예약자는 7일 이내 재방문 안내 및 예약 확인', note:''};
};
const fmtMed = (m) => (m===null || m===undefined) ? '-' : (Math.round(m) + '일');

// used age columns
const usedAges13 = new Set();
followMap.forEach(o=>{
  if(AGE_BUCKETS.includes(o.연령대)) usedAges13.add(o.연령대);
});
const ageCols13 = AGE_BUCKETS.filter(a=>usedAges13.has(a));
const finalAgeCols13 = (ageCols13 && ageCols13.length) ? ageCols13 : AGE_BUCKETS.filter(a=>a!=='미상');

// therapist -> byAge
const t13Map = new Map();
followMap.forEach(o=>{
  const t = o.치료사;
  if(!t13Map.has(t)) t13Map.set(t, {therapist:t, byAge:new Map()});
  t13Map.get(t).byAge.set(o.연령대, o);
});

function buildTherapistFollowTable(tObj){
  const cols = finalAgeCols13;
  let totN = 0, totOne = 0, totR7 = 0, totR14 = 0;
  let allDays = [];
  cols.forEach(a=>{
    const o = tObj.byAge.get(a);
    if(!o) return;
    totN += (o.n||0);
    totOne += (o.one||0);
    totR7 += (o.r7||0);
    totR14 += (o.r14||0);
    if(o.days && o.days.length) allDays = allDays.concat(o.days);
  });
  const oneRateT = totN ? (totOne/totN) : 0;
  const r7RateT  = totN ? (totR7/totN) : 0;
  const r14RateT = totN ? (totR14/totN) : 0;
  const medT = allDays.length ? median(allDays) : null;
  const recT = recFor(totN, oneRateT, r7RateT);

  const thead = `<thead><tr><th style="width:160px;">구분</th>` +
    cols.map(c=>`<th>${c}</th>`).join('') +
    `<th class="total-col">전체</th></tr></thead>`;

  const td = (v)=>`<td>${v===null||v===undefined||v===''?'-':v}</td>`;

  const row = (label, cellFn, totalVal) => {
    let cells = '';
    cols.forEach(a=>{
      const o = tObj.byAge.get(a);
      cells += td(cellFn(o));
    });
    cells += `<td class="total-col">${totalVal}</td>`;
    return `<tr><td class="kpiRowLabel">${label}</td>${cells}</tr>`;
  };

  const tbody = `<tbody>` +
    row('신환 수(명)', o => o ? fmtInt(o.n||0) : '-', `<b>${fmtInt(totN)}</b>`) +
    row('1회만 내원 비율', o => {
        if(!o || !o.n) return '-';
        return fmtPct((o.one||0)/(o.n||1));
      }, `<b>${fmtPct(oneRateT)}</b>`) +
    row('7일 내 재방문율', o => {
        if(!o || !o.n) return '-';
        return fmtPct((o.r7||0)/(o.n||1));
      }, `<b>${fmtPct(r7RateT)}</b>`) +
    row('14일 내 재방문율', o => {
        if(!o || !o.n) return '-';
        return fmtPct((o.r14||0)/(o.n||1));
      }, `<b>${fmtPct(r14RateT)}</b>`) +
    row('2회차 재방문 주기(중간값)', o => {
        if(!o || !o.n) return '-';
        const m = (o.days && o.days.length) ? median(o.days) : null;
        return fmtMed(m);
      }, `<b>${fmtMed(medT)}</b>`) +
    row('권장 연락', o => {
        if(!o || !o.n) return '-';
        const oneR = (o.one||0)/(o.n||1);
        const r7R = (o.r7||0)/(o.n||1);
        return recFor(o.n||0, oneR, r7R).rec;
      }, `<b>${recT.rec}</b>`) +
    `</tbody>`;

  return `
    <div class="subtableCard">
      <div class="subtableHeader">
        <div class="name">${tObj.therapist}</div>
        <div class="meta">신환 ${fmtInt(totN)}명</div>
      </div>
      <div style="overflow-x:auto;">
        <table>${thead}${tbody}</table>
      </div>
    </div>
  `;
}

const t13List = Array.from(t13Map.values()).sort((a,b)=>toStr(a.therapist).localeCompare(toStr(b.therapist),'ko'));
if(t13List.length===0){
  setHtml('table13', '<div class="muted">표시할 데이터가 없습니다.</div>');
}else{
  setHtml('table13', `<div class="subtablesGrid">` + t13List.map(buildTherapistFollowTable).join('') + `</div>`);
}

// 요약(Top 5) 계산용 rows
const followRows = Array.from(followMap.values()).map(o=>{
  const n0 = o.n || 0;
  const oneRate = n0 ? (o.one/n0) : 0;
  const r7Rate = n0 ? (o.r7/n0) : 0;
  const r14Rate = n0 ? (o.r14/n0) : 0;
  const med = o.days.length ? median(o.days) : null;
  const rec = recFor(n0, oneRate, r7Rate);
  return {
    '치료사': o.치료사,
    '연령대': o.연령대,
    '권장 연락': rec.rec,
    '비고': rec.note,
    _n: n0,
    _oneRate: oneRate,
    _r7: r7Rate,
    _r14: r14Rate,
    _med: med,
    _score: ((oneRate||0)*0.55 + (1-(r7Rate||0))*0.35 + (med===null?0:Math.min(1, med/14))*0.10)
  };
});

// 표 13 하단: 재방문 관리 요약(Top 5)
renderFollowSummary(followRows, 'followSummary13');

// 제안서 텍스트 (조건에 따라 자동 확장, 줄 수 제한 없음)
      const lines = [];
      const marks = ['①','②','③','④','⑤','⑥','⑦','⑧','⑨','⑩','⑪','⑫'];
      const addLine = (htmlLine)=>{
        const m = marks[lines.length] || ((lines.length+1) + '.');
        lines.push(`${m} ${htmlLine}`);
      };

      if(n===0){
        addLine("선택된 조건에 해당하는 신환(도수치료) 데이터가 없습니다. 치료금액 필터를 '전체'로 바꾸거나 원본 데이터를 확인해주세요.");
      }else{
        // 기본 5줄 (항상 제공)
        addLine(`<b>2회 이상 치료 비율</b>은 <b>${fmtPct(convN/n)}</b> 입니다. <u>첫 치료 당일에 2회차 예약을 선점</u>하고, 미예약자는 <u>재방문 안내 연락 시점(7~10일) 및 예약 확인</u>를 권장합니다.`);
        addLine(`<b>3회 이상 치료 비율</b>은 <b>${fmtPct(r3N/n)}</b> 입니다. <u>4주 내 5회 치료</u>를 목표로, 초진에서 <u>5회 계획(일정)</u>을 먼저 확정하고 <u>3회차는 중간 관문</u>으로 관리하세요. 치료 횟수별로 <u>통증/기능 지표</u>를 기록해 동기부여를 강화하면 5회 도달률을 끌어올릴 수 있습니다.`);
        addLine(`<b>주사치료 병행 비율</b>은 <b>${fmtPct(comboN/n)}</b> 입니다. 병행 비중이 높으면 <u>동의/안내/진료 안내 기준</u>을 표준화해 CS를 줄이고, 병행 기준을 팀 내 합의로 정리하세요.`);
        addLine(`<b>7일 내 재방문율</b>은 <b>${fmtPct(r7N/n)}</b>, <b>14일 내 재방문율</b>은 <b>${fmtPct(r14N/n)}</b> 입니다. 7일이 낮고 14일만 높은 경우, <u>예약 대기기간</u>과 <u>스케줄 병목</u>을 우선 점검하세요.`);
        addLine(`치료사별(표 8)로 전환/유지 편차가 크면, <u>초진 설명 문구</u>와 <u>치료 횟수별 목표/기록 템플릿</u>을 통일해 성과를 평준화하는 것이 1순위입니다.`);
        addLine(`<b>치료사별 신환/재진 예약 비율(표 8-1)</b>을 함께 보세요. 신환 예약이 낮으면 <u>초진 당일 예약확정</u>과 <u>미예약자 재방문 안내 연락 시점(7~10일) 및 예약 확인</u>을 표준 프로세스로 두는 것이 효과적입니다.`);
        addLine(`<b>진료실별 핵심지표(표 10)</b>에서 병목이 생기는 진료실이 있으면, <u>진료실별 슬롯(가용시간)·동선·보조인력 배치</u>를 먼저 손보는 것이 전환 개선에 빠릅니다.`);
        addLine(`<b>치료사·연령대별 평균/분포(표 11~12)</b>를 기준으로, <u>연령대별 설명 난이도</u>와 <u>follow-up(재방문 안내 연락 시점 및 예약 확인)</u> 메시지를 표준화하면 ‘우연한 성과’를 ‘재현 가능한 성과’로 만들 수 있습니다.`);

        // ---- 추가 인사이트 (조건 충족 시 6~10줄로 확장)
        const oneN = cohort.filter(p => p.shockVisitCount === 1).length;
        if(oneN/n >= 0.35){
          addLine(`<b>1회 종료 비중</b>이 높습니다(<b>${fmtPct(oneN/n)}</b>). 초진에서 <u>‘왜 4주 내 5회가 필요한지’</u>를 구조적으로 설명하고, <u>2회차 예약/결제 동선</u>을 단순화하세요.`);
        }

        // 치료사 편차(2회 이상 치료 비율 기준)
        const tStats = Array.from(new Set(cohort.map(p=>p.therapist))).map(t=>{
          const ps = cohort.filter(p=>p.therapist===t);
          const nn = ps.length;
          const cc2 = ps.filter(p=>p.shockVisitCount>=2).length;
          const rr3 = ps.filter(p=>p.shockVisitCount>=3).length;
          return {t, n: nn, c2: nn?cc2/nn:0, r3: nn?rr3/nn:0};
        }).filter(x=>x.n>=5); // 표본 너무 작은 치료사 제외
        if(tStats.length>=2){
          const maxC2 = Math.max(...tStats.map(x=>x.c2));
          const minC2 = Math.min(...tStats.map(x=>x.c2));
          if((maxC2 - minC2) >= 0.20){
            const best = tStats.reduce((a,b)=> b.c2>a.c2?b:a, tStats[0]);
            const worst = tStats.reduce((a,b)=> b.c2<a.c2?b:a, tStats[0]);
            addLine(`치료사별 <b>2회 이상 치료 비율 편차</b>가 큽니다(<b>${fmtPct(maxC2)}</b> vs <b>${fmtPct(minC2)}</b>). <u>${best.t}</u>의 초진 운영을 좋은 사례로 참고하고, <u>${worst.t}</u> 구간은 예약/설명/기록을 코칭하세요.`);
          }
        }

        // 연령대별 병목(2회 이상 치료 비율 최저 연령대)
        const aStats = ageCols.map(a=>{
          const ps = cohort.filter(p => (p.ageBucket||'미상') === a);
          const nn = ps.length;
          const cc2 = ps.filter(p=>p.shockVisitCount>=2).length;
          const rr7 = ps.filter(p=>p.daysTo2!==null && p.daysTo2<=7).length;
          return {a, n: nn, c2: nn?cc2/nn:0, r7: nn?rr7/nn:0};
        }).filter(x=>x.n>=10);
        if(aStats.length){
          const worst = aStats.reduce((a,b)=> b.c2<a.c2?b:a, aStats[0]);
          addLine(`<b>${worst.a}</b>에서 <b>2회차 전환</b>이 상대적으로 약합니다. 이 연령대는 <u>예약 시간대(야간/주말)</u>와 <u>커뮤니케이션 채널(SMS/카톡)</u>을 최적화해 개선 여지가 큽니다.`);
        }

        
      }

      // 최소 5줄 보장
      while(lines.length < 5 && n>0){
        addLine("표 1~9의 분포를 확인해 <u>전환이 약한 구간</u>부터 우선순위로 개선안을 적용하세요.");
      }
      const finalLines = lines;

document.getElementById('analysisText').innerHTML = finalLines.map(x=>`<div style="margin:4px 0;">${x}</div>`).join('');
    }
  

</script>
</body>
</html>
