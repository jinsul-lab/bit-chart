<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>JINSUL - 전략 분석 시스템 (v 0.0.4.2)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root { --blue: #228be6; --border: rgba(0, 0, 0, 0.1); --text: #1f2937; --gray: #868e96; }
    * { box-sizing: border-box; font-family: system-ui, sans-serif; }
    body { margin: 0; background: #f8f9fa; color: var(--text); min-height: 100vh; display: flex; flex-direction: column; overflow-x: hidden; }

    .version-tag { position: absolute; top: 10px; left: 10px; font-size: 10px; color: var(--gray); opacity: 0.5; font-weight: bold; }

    .watermark { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 550px; opacity: 0.1; z-index: -1; pointer-events: none; filter: grayscale(1); }

    header { padding: 40px 0 20px; text-align: center; }
    header img { width: 180px; filter: grayscale(1) brightness(0.5); margin-bottom: 10px; }

    .container { max-width: 1260px; margin: 0 auto; padding: 0 10px; flex: 1; width: 100%; }

    .card { background: rgba(255, 255, 255, 0); padding: 14px; border-radius: 12px; border: 1px solid var(--border); margin-bottom: 10px; }
    .card h2 { margin: 0 0 10px; font-size: 16px; border-left: 4px solid var(--blue); padding-left: 10px; }

    .drop-zone { border: 2px dashed #cbd5e1; padding: 26px; text-align: center; border-radius: 10px; background: rgba(255, 255, 255, 0.5); cursor: pointer; }
    .drop-zone.active { border-color: var(--blue); background: rgba(34, 139, 230, 0.1); }

    .cards-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 20px; }
    @media (max-width: 980px){ .cards-grid{ grid-template-columns: 1fr; } }

    .dashboard-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(190px, 1fr)); gap: 8px; margin-bottom: 10px; }
    .dash-item { background: #fff; padding: 12px; border-radius: 10px; border: 1px solid var(--border); text-align: center; }
    .dash-item .val { font-size: 24px; font-weight: 800; color: var(--blue); }
    .dash-item .sub { font-size: 11px; color: var(--gray); margin-top: 3px; }

    .price-btn { padding: 5px 10px; border-radius: 6px; border: 1px solid #dee2e6; background: #fff; cursor: pointer; font-size: 12px; margin: 2px; transition: 0.2s; }
    .price-btn.active { background: var(--blue); color: #fff; border-color: var(--blue); font-weight: bold; box-shadow: 0 2px 4px rgba(34, 139, 230, 0.3); }

    .price-btn.excl-btn { border-style: dashed; }
    .price-btn.excl-btn.active { background: var(--gray); color: #fff; border-color: var(--gray); box-shadow: none; font-weight: bold; }

    .filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 980px){ .filter-grid{ grid-template-columns: 1fr; } }

    table { width: 100%; border-collapse: collapse; background: transparent; table-layout: fixed; }
    th { background: rgba(241, 243, 245, 0.85); padding: 7px 6px; border: 1px solid #dee2e6; text-align: center; font-size: 12px; }
    td { padding: 7px 6px; border: 1px solid var(--border); font-size: 12px; text-align: center; }
    .total-col { background: rgba(34, 139, 230, 0.1); font-weight: bold; }
    .total-row td { background: rgba(34, 139, 230, 0.08); font-weight: bold; }
    .hidden { display: none; }

    footer { text-align: center; padding: 30px 20px; color: var(--gray); font-size: 0.95rem; font-weight: 500; width: 100%; position: relative; z-index: 10; }
  </style>
</head>
<body>
  <div class="version-tag">v 0.0.4.2</div>
  <img src="jinsul-logo.png" class="watermark" alt="bg" />
  <header>
    <img src="jinsul-logo.png" alt="logo" />
    <div style="font-weight: bold; font-size: 18px;">신환 충격파 전략 분석 리포트</div>
  </header>

  <div class="container">
    <div class="card">
      <div class="drop-zone" id="dropZone">
        <strong id="statusText">데이터 업로드 (드래그/클릭)</strong>
        <input type="file" id="fileInput" class="hidden" accept=".csv, .xlsx" />
      </div>
    </div>

    <div id="dashArea" class="dashboard-grid hidden">
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">신환 수</div>
        <div id="v-count" class="val">0</div>
        <div id="v-count-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">2회차 전환율</div>
        <div id="v-conv" class="val">0%</div>
        <div id="v-conv-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">3회차 유지율</div>
        <div id="v-ret" class="val">0%</div>
        <div id="v-ret-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">주사치료 병행 비율</div>
        <div id="v-combo" class="val">0%</div>
        <div id="v-combo-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">평균 치료 횟수</div>
        <div id="v-avgV" class="val">0.0</div>
        <div class="sub">충격파 치료일 기준</div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">중간값 치료 횟수</div>
        <div id="v-medV" class="val">0</div>
        <div class="sub">충격파 치료일 기준</div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">가장 흔한 치료 횟수(최빈값)</div>
        <div id="v-modeV" class="val">-</div>
        <div id="v-modeV-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">7일 내 재방문율</div>
        <div id="v-r7" class="val">0%</div>
        <div id="v-r7-sub" class="sub"></div>
      </div>
      <div class="dash-item">
        <div style="font-size:12px;color:var(--gray);">14일 내 재방문율</div>
        <div id="v-r14" class="val">0%</div>
        <div id="v-r14-sub" class="sub"></div>
      </div>
</div>

    <div id="filterArea" class="card hidden">
  <h2>치료 금액 선택</h2>
  <div class="filter-grid">
    <div>
      <div style="font-size:13px;color:var(--gray);margin-bottom:6px;">포함할 치료 금액 (단일 선택)</div>
      <div id="priceBtns"></div>
    </div>
    <div>
      <div style="font-size:13px;color:var(--gray);margin-bottom:6px;">제외할 치료 금액 (복수 선택)</div>
      <div id="excludeBtns"></div>
      <div style="font-size:12px;color:var(--gray);margin-top:4px;">※ 제외된 금액으로 시작한 신환은 분석에서 제외됩니다.</div>
    </div>
  </div>
</div>

<div id="mainContent" class="hidden">
      <div class="cards-grid">
      <div class="card"><h2>표 1. 부위별 치료 횟수</h2><div style="overflow-x:auto;"><table id="table1"></table></div></div>
      <div class="card"><h2>표 2. 신환 상세 통계 및 재진 전환율</h2><div style="overflow-x:auto;"><table id="table2"></table></div></div>
      <div class="card"><h2>표 3. 연령대별 충격파 치료 건수</h2><div style="overflow-x:auto;"><table id="table3"></table></div></div>
      <div class="card"><h2>표 4. 연령대별 성별 치료 비중</h2><div style="overflow-x:auto;"><table id="table4"></table></div></div>
      <div class="card"><h2>표 5. 충격파 치료 횟수 분포</h2><div style="overflow-x:auto;"><table id="table5"></table></div></div>
      <div class="card"><h2>표 6. 연령대별 치료 횟수 인원 분포</h2><div style="overflow-x:auto;"><table id="table6"></table></div></div>

      <div class="card"><h2>표 7. 치료 금액 구간별 핵심지표</h2><div style="overflow-x:auto;"><table id="table7"></table></div></div>
      <div class="card"><h2>표 8. 치료사별 핵심지표</h2><div style="overflow-x:auto;"><table id="table8"></table></div></div>
      <div class="card"><h2>표 9. 첫 치료 → 2회차 재방문 주기</h2><div style="overflow-x:auto;"><table id="table9"></table></div></div>

      <div class="card" style="background: rgba(231, 245, 255, 0.6);">
        <h2>병원 경영 전략 제안서</h2>
        <div id="analysisText" style="line-height:1.7; font-size:13px; color:#333; padding: 4px;"></div>
      </div>
      </div>
    </div>
  </div>

  <footer>© JINSUL · 경험과 가치를 현실화하는 컨설팅</footer>

  <script>
    // -----------------------------
    // 0) UI 이벤트
    // -----------------------------
    const dz = document.getElementById('dropZone');
    const fi = document.getElementById('fileInput');

    dz.onclick = () => fi.click();
    fi.onchange = e => handleFile(e.target.files && e.target.files[0]);

    ['dragenter','dragover'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); dz.classList.add('active'); }));
    ['dragleave','drop'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); dz.classList.remove('active'); }));
    dz.addEventListener('drop', e => handleFile(e.dataTransfer.files && e.dataTransfer.files[0]));

    // -----------------------------
    // 1) 전역 상태
    // -----------------------------
    let rawRows = [];
    let records = [];     // row-level cleaned
    let patientsAll = []; // patient-level aggregated (전체)
    let selPVal = -1;     // selected entry price
    let entryPriceList = [];
    let amountListAll = [];
    let exclAmtSet = new Set();

    const AGE_BUCKETS = ['10대','20대','30대','40대','50대','60대','70대 이상','미상'];
    const GENDERS = ['남','여','미상'];

    function toStr(v){ return (v===null||v===undefined) ? "" : String(v); }
    function normKey(k){ return toStr(k).trim(); }
    function num(v){
      const n = parseInt(toStr(v).replace(/[^0-9]/g,''),10);
      return isFinite(n) ? n : 0;
    }

    function moneyOrNull(v){
      // 금액 파싱: 숫자가 전혀 없으면 null(없음)로 처리 (공란을 0원으로 만들지 않기 위함)
      if(v===null || v===undefined) return null;
      if(typeof v === 'number' && isFinite(v)) return Math.round(v);
      const digits = toStr(v).replace(/[^0-9]/g,'');
      if(!digits) return null;
      const n = parseInt(digits,10);
      return isFinite(n) ? n : null;
    }

    function normalizeType(v){
      const s = toStr(v).replace(/\s+/g,'').replace(/,+/g,'').trim();
      return s;
    }
    function isShock(t){ return normalizeType(t).includes('충격파'); }
    function isInjection(t){ const s=normalizeType(t); return s.includes('주사'); }
    function isManual(t){ return normalizeType(t).includes('도수'); }

    function parseVisitDate(v){
      // returns Date or null
      if(v===null || v===undefined || v==="") return null;

      // number: could be yyyymmdd (e.g., 20251101.0) or excel serial (e.g., 45200)
      if(typeof v === 'number' && isFinite(v)){
        const iv = Math.floor(v);
        const s = String(iv);
        if(s.length === 8 && iv > 19000101 && iv < 20991231){
          const y = parseInt(s.slice(0,4),10);
          const m = parseInt(s.slice(4,6),10)-1;
          const d = parseInt(s.slice(6,8),10);
          const dt = new Date(y,m,d);
          return isFinite(dt.getTime()) ? dt : null;
        }
        // excel serial heuristic
        if(iv > 20000 && iv < 60000){
          const base = new Date(Date.UTC(1899,11,30)); // Excel epoch
          const dt = new Date(base.getTime() + iv * 86400000);
          return isFinite(dt.getTime()) ? new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()) : null;
        }
      }

      // string formats
      const s0 = toStr(v).trim();
      if(!s0) return null;

      // yyyymmdd as string
      const s = s0.replace(/\s+/g,'');
      if(/^\d{8}(\.0+)?$/.test(s)){
        const s8 = s.slice(0,8);
        const y = parseInt(s8.slice(0,4),10);
        const m = parseInt(s8.slice(4,6),10)-1;
        const d = parseInt(s8.slice(6,8),10);
        const dt = new Date(y,m,d);
        return isFinite(dt.getTime()) ? dt : null;
      }

      // yyyy-mm-dd / yyyy/mm/dd
      const m1 = s.match(/^(\d{4})[-\/.](\d{1,2})[-\/.](\d{1,2})/);
      if(m1){
        const y = parseInt(m1[1],10);
        const mo = parseInt(m1[2],10)-1;
        const d = parseInt(m1[3],10);
        const dt = new Date(y,mo,d);
        return isFinite(dt.getTime()) ? dt : null;
      }

      const dt = new Date(s0);
      return isFinite(dt.getTime()) ? new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()) : null;
    }


    function normalizeRecords(recs){
      // 방문(환자+방문일+치료타입+회차+치료사) 단위로 묶어서,
      // 금액이 비어있는 행(부위가 분리 출력된 행)에도 같은 방문 금액을 전파한다.
      const g = new Map();
      const keyOf = (r)=>[r.key, r.therapist||'', String(r.visitKey||''), normalizeType(r.typeRaw||''), toStr(r.round||'')].join('||');
      for(const r of recs){
        const k = keyOf(r);
        if(!g.has(k)) g.set(k, []);
        g.get(k).push(r);
      }
      for(const rows of g.values()){
        const amts = rows.map(x=>x.amount).filter(v=>isFinite(v) && v>0);
        const a = amts.length ? Math.max(...amts) : null;
        if(a!==null){
          rows.forEach(x=>{ if(x.amount===null || x.amount===undefined || x.amount===0) x.amount = a; });
        }
        const t = rows.map(x=>toStr(x.typeRaw).trim()).find(v=>v) || '';
        const rd = rows.map(x=>toStr(x.round).trim()).find(v=>v) || '';
        rows.forEach(x=>{
          if(!toStr(x.typeRaw).trim()) x.typeRaw = t;
          if(!toStr(x.round).trim()) x.round = rd;
        });
      }
      return recs;
    }


    function dateKey(d){
      if(!d) return null;
      const dd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
      return dd.getTime();
    }

    function parseGender(sexAge){
      const s = toStr(sexAge);
      if(s.includes('남')) return '남';
      if(s.includes('여')) return '여';
      return '미상';
    }
    function parseAgeBucket(sexAge){
      const s = toStr(sexAge);
      const m = s.match(/(\d{1,3})/);
      if(!m) return '미상';
      const age = parseInt(m[1],10);
      if(!isFinite(age)) return '미상';
      if(age < 20) return '10대';
      if(age < 30) return '20대';
      if(age < 40) return '30대';
      if(age < 50) return '40대';
      if(age < 60) return '50대';
      if(age < 70) return '60대';
      return '70대 이상';
    }

    
function mapPartSingle(partRaw){
  const s0 = toStr(partRaw).trim();
  if(!s0) return null;
  const s = s0.replace(/\s+/g,'').replace(/[，]/g,'').replace(/,+/g,'').replace(/[.]+$/,'');
  const has = (w)=>s.includes(w);
  // 손가락/발가락 포함 규칙 반영
  if(has('경추') || has('목')) return '목';
  if(has('흉추') || (has('등') && !has('허리'))) return '등';
  if(has('요추') || has('허리')) return '허리';
  if(has('어깨') || has('견')) return '어깨';
  if(has('팔꿈치') || has('주관절')) return '팔꿈치';
  if(has('손가락') || has('수지') || has('손목') || has('손')) return '손목/손';
  if(has('고관절') || has('골반') || has('둔부') || has('엉덩') || has('서혜')) return '골반/고관절';
  if(has('무릎') || has('슬관절')) return '무릎';
  if(has('발가락') || has('족지') || has('발목') || has('발')) return '발목/발';
  return '기타';
}

function extractParts(partRaw){
  const s0 = toStr(partRaw).trim();
  if(!s0) return ['(미기입)'];

  const s = s0
    .replace(/\n/g, ',')
    .replace(/[\/／]/g, ',')
    .replace(/[·•]/g, ',')
    .replace(/\s*및\s*/g, ',')
    .replace(/&/g, ',');

  const tokens = s.split(',').map(x=>x.trim()).filter(Boolean);
  const out = [];
  const push = (v)=>{ if(v && !out.includes(v)) out.push(v); };

  if(tokens.length){
    tokens.forEach(t=>{
      const m = mapPartSingle(t);
      push(m || '기타');
    });
  }else{
    const m = mapPartSingle(s0);
    push(m || '기타');
  }

  return out.length ? out : ['(미기입)'];
}

function fmtPct(x){ return (isFinite(x) ? (x*100).toFixed(1) : '0.0') + '%'; }
    function fmtInt(x){ return (isFinite(x) ? Math.round(x).toLocaleString() : '0'); }
    function median(arr){
      const a = arr.slice().sort((x,y)=>x-y);
      if(!a.length) return 0;
      const mid = Math.floor(a.length/2);
      return a.length%2 ? a[mid] : (a[mid-1]+a[mid])/2;
    }

    function modeInfo(arr){
      const freq = new Map();
      for(const v of (arr||[])){
        const k = (v===null||v===undefined) ? null : Number(v);
        if(!isFinite(k)) continue;
        freq.set(k, (freq.get(k)||0) + 1);
      }
      if(!freq.size) return {modes:[], maxFreq:0};
      let maxF = 0;
      for(const c of freq.values()) maxF = Math.max(maxF, c);
      const modes = Array.from(freq.entries()).filter(([k,c])=>c===maxF).map(([k])=>k).sort((a,b)=>a-b);
      return {modes, maxFreq:maxF};
    }


    // -----------------------------
    // 2) 파일 로드 -> 정규화 -> 환자 집계
    // -----------------------------
    function handleFile(file){
      if(!file) return;
      document.getElementById('statusText').textContent = `로드됨: ${file.name}`;

      const r = new FileReader();
      r.onload = e => {
        const wb = XLSX.read(new Uint8Array(e.target.result), {type:'array'});
        rawRows = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], {defval:""});
        buildData();
        selPVal = -1;
        buildPriceButtons();
        buildExcludeButtons();
        renderAll();
        };
      r.readAsArrayBuffer(file);
    }

    function buildData(){
      // 1) 키 정리
      const cleaned = rawRows.map(row => {
        const out = {};
        Object.keys(row||{}).forEach(k => out[normKey(k)] = row[k]);
        return out;
      });

      // 2) 치료사/환자 컨텍스트 ffill
      let ctx = { therapist:'', name:'', chart:'', sexAge:'', newFlag:'', visitDt:null, typeRaw:'', round:'' };

      const recs = [];
      for(const r of cleaned){
        const no = toStr(r['번호']).trim();
        if(no && no.includes('치료사') && no.includes('환자')){
          // ex) "김기목 치료사 환자 현황"
          const t = no.split('치료사')[0].trim();
          ctx.therapist = t || ctx.therapist;
          ctx.name = '';
          ctx.chart = '';
          ctx.sexAge = '';
          ctx.newFlag = '';
          ctx.visitDt = null;
          ctx.typeRaw = '';
          ctx.round = '';
          continue; // 헤더 행 제외
        }

        const name = toStr(r['이름']).trim();
        if(name){
          ctx.name = name;
          const c = toStr(r['환자 차트']).trim();
          if(c) ctx.chart = c;
          const sa = toStr(r['성별/연령']).trim();
          if(sa) ctx.sexAge = sa;
          const nf = toStr(r['신/재']).trim();
          if(nf) ctx.newFlag = nf;
        }

        // 실제 데이터가 거의 없는 빈 행은 스킵
        const maybeData = ctx.name || toStr(r['치료부위']).trim() || toStr(r['치료타입']).trim();
        if(!maybeData) continue;

        let visitDt = parseVisitDate(r['방문일']);
        if(visitDt) ctx.visitDt = visitDt;
        else visitDt = ctx.visitDt || null;
        const vk = dateKey(visitDt);

        let rt = toStr(r['치료타입']).trim();
        if(rt) ctx.typeRaw = rt;
        else rt = ctx.typeRaw || '';

        let round = toStr(r['치료차수']).trim();
        if(round) ctx.round = round;
        else round = ctx.round || '';

        const amt = moneyOrNull(r['금액']);

        const sexAge = toStr(r['성별/연령']).trim() || ctx.sexAge;
        const newFlag = toStr(r['신/재']).trim() || ctx.newFlag;

        const chart = toStr(r['환자 차트']).trim() || ctx.chart;

        recs.push({
          therapist: ctx.therapist || '미상',
          name: ctx.name,
          chart: chart,
          key: (chart ? (chart+'|'+ctx.name) : ctx.name),
          sexAge: sexAge,
          gender: parseGender(sexAge),
          ageBucket: parseAgeBucket(sexAge),
          newFlag: newFlag,
          part: toStr(r['치료부위']).trim() || '(미기입)',
          typeRaw: rt,
          type: normalizeType(rt),
          amount: amt,
          visitKey: vk,
          visitDate: visitDt,
          round: round
        });
      }

      records = normalizeRecords(recs);

      patientsAll = computePatientsFrom(records);

      // 치료 금액(첫 충격파 치료금액) 후보는 데이터에 따라 유동적입니다.
      amountListAll = Array.from(new Set(
        patientsAll.filter(p=>p.isNew)
          .map(p=>p.entryPrice)
          .filter(v=>isFinite(v) && v>0)
      )).sort((a,b)=>a-b);

      exclAmtSet = new Set();
      rebuildDerived();
}

    function computePatientsFrom(sourceRecords){
      const byP = new Map();
      for(const row of (sourceRecords||[])){
        if(!row.key) continue;
        if(!byP.has(row.key)) byP.set(row.key, []);
        byP.get(row.key).push(row);
      }

      const pats = [];
      for(const [pkey, rows] of byP.entries()){
        const any = rows[0];
        const isNew = rows.some(r => toStr(r.newFlag).includes('신환'));
        const hasShock = rows.some(r => isShock(r.typeRaw));
        if(!hasShock) continue; // 충격파 경험자만
        const hasInj = rows.some(r => isInjection(r.typeRaw));
        const hasMan = rows.some(r => isManual(r.typeRaw));

        const visitKeysAll = new Set(rows.map(r=>r.visitKey).filter(Boolean));
        const shockVisitKeys = new Set(rows.filter(r=>isShock(r.typeRaw)).map(r=>r.visitKey).filter(Boolean));

        const allKeys = Array.from(visitKeysAll).sort((a,b)=>a-b);
        const shKeys  = Array.from(shockVisitKeys).sort((a,b)=>a-b);
        const firstAll = allKeys.length ? allKeys[0] : null;
        const firstShock = shKeys.length ? shKeys[0] : firstAll;

        let entry = null;
        if(firstShock !== null){
          const shRows = rows.filter(r => r.visitKey===firstShock && isShock(r.typeRaw));
          const am1 = shRows.map(r=>r.amount).filter(v=>isFinite(v));
          entry = am1.length ? Math.max(...am1) : null;
          if(entry===null){
            const allRows = rows.filter(r => r.visitKey===firstShock);
            const am2 = allRows.map(r=>r.amount).filter(v=>isFinite(v));
            entry = am2.length ? Math.max(...am2) : null;
          }
        }
let daysTo2 = null;
        if(shKeys.length >= 2){
          daysTo2 = Math.max(0, Math.round((shKeys[1]-shKeys[0]) / 86400000));
        }

        pats.push({
          key: pkey,
          therapist: any.therapist || '미상',
          name: any.name,
          chart: any.chart,
          gender: any.gender,
          ageBucket: any.ageBucket,
          isNew: isNew,
          entryPrice: entry,
          visitCountAll: visitKeysAll.size,
          shockVisitCount: shockVisitKeys.size,
          firstShockKey: firstShock,
          daysTo2: daysTo2,
          hasInjection: hasInj,
          hasManual: hasMan,
          rows: rows
        });
      }
      return pats;
    }

    function activePatients(){
  // 제외된 치료 금액(첫 충격파 치료금액)으로 시작한 신환은 분석에서 제외
  if(!exclAmtSet || !exclAmtSet.size) return patientsAll.slice();
  return patientsAll.filter(p => !(p.isNew && isFinite(p.entryPrice) && exclAmtSet.has(p.entryPrice)));
}

function rebuildDerived(){
  const act = activePatients();
  entryPriceList = Array.from(new Set(
    act.filter(p=>p.isNew)
      .map(p=>p.entryPrice)
      .filter(v=>isFinite(v) && v>0)
  )).sort((a,b)=>a-b);

  // 선택 금액이 더 이상 존재하지 않으면 '전체'로 복귀
  if(selPVal !== -1 && !entryPriceList.includes(selPVal)) selPVal = -1;
}


    // -----------------------------
    // 3) 필터 버튼
    // -----------------------------
function buildPriceButtons(){
      const box = document.getElementById('priceBtns');
      box.innerHTML = '';

      const mkBtn = (label, val) => {
        const b = document.createElement('button');
        b.className = 'price-btn sel-btn' + (selPVal===val ? ' active' : '');
        b.textContent = label;
        b.onclick = () => {
          selPVal = val;
          document.querySelectorAll('.sel-btn').forEach(x => x.classList.remove('active'));
          b.classList.add('active');
          renderAll();
        };
        return b;
      };

      box.appendChild(mkBtn('전체', -1));
      entryPriceList.forEach(v => box.appendChild(mkBtn(v.toLocaleString() + '원', v)));

      document.getElementById('filterArea').classList.remove('hidden');
    }

    function buildExcludeButtons(){
      const box = document.getElementById('excludeBtns');
      if(!box) return;
      box.innerHTML = '';

      const mkBtn = (label, val) => {
        const b = document.createElement('button');
        b.className = 'price-btn excl-btn' + (exclAmtSet.has(val) ? ' active' : '');
        b.textContent = label;
        b.onclick = () => {
          if(exclAmtSet.has(val)) exclAmtSet.delete(val);
          else exclAmtSet.add(val);

          rebuildDerived();
          buildPriceButtons();
          buildExcludeButtons();
          renderAll();
        };
        return b;
      };

      // 금액 후보(원 데이터 기준) + 현재 제외값 union
      const union = Array.from(new Set([...(amountListAll||[]), ...Array.from(exclAmtSet||[])]))
        .filter(v=>isFinite(v) && v>0)
        .sort((a,b)=>a-b);

      union.forEach(v => box.appendChild(mkBtn(v.toLocaleString() + '원', v)));

      // 초기화
      const clearBtn = document.createElement('button');
      clearBtn.className = 'price-btn excl-btn' + (exclAmtSet.size ? '' : ' active');
      clearBtn.textContent = '제외 초기화';
      clearBtn.onclick = () => {
        exclAmtSet = new Set();
        rebuildDerived();
        buildPriceButtons();
        buildExcludeButtons();
        renderAll();
      };
      box.appendChild(clearBtn);
    }


    // -----------------------------
    // 4) 렌더링 헬퍼
    // -----------------------------
    function setHtml(id, html){ const el = document.getElementById(id); if(el) el.innerHTML = html; }

    function renderKeyValueTable(tableId, rows){
      // rows: [{k, v}]
      const h = `<thead><tr><th style="width:180px;">항목</th><th>값</th></tr></thead><tbody>` +
        rows.map(r=>`<tr><td>${r.k}</td><td>${r.v}</td></tr>`).join('') +
        `</tbody>`;
      setHtml(tableId, h);
    }

    function renderSimpleTable(tableId, cols, rows){
      // cols: [{k:'field', l:'label', w?:number}]
      const thead = `<thead><tr>` + cols.map(c=>{
        const w = c.w ? ` style="width:${c.w}px"` : '';
        return `<th${w}>${c.l}</th>`;
      }).join('') + `</tr></thead>`;

      const tbody = `<tbody>` + (rows||[]).map(r=>{
        const cls = (r && r._rowClass) ? ` class="${r._rowClass}"` : '';
        return `<tr${cls}>` + cols.map(c=>{
          const v = (r && (r[c.k]!==null && r[c.k]!==undefined)) ? r[c.k] : '';
          return `<td>${v}</td>`;
        }).join('') + `</tr>`;
      }).join('') + `</tbody>`;

      setHtml(tableId, thead + tbody);
    }

    function renderMatrix(tableId, rowLabels, colLabels, getVal){
      // Adds both row totals (right) and column totals (bottom)
      const head = `<thead><tr><th style="width:110px;">구분</th>` +
        colLabels.map(c=>`<th>${c}</th>`).join('') +
        `<th class="total-col">총 합계</th></tr></thead>`;

      const colTotals = new Array(colLabels.length).fill(0);
      let grand = 0;

      let body = `<tbody>`;
      rowLabels.forEach((rLabel, ri) => {
        let rowSum = 0;
        let cells = '';
        colLabels.forEach((cLabel, ci) => {
          const v = getVal(rLabel, cLabel) || 0;
          rowSum += v;
          colTotals[ci] += v;
          cells += `<td>${v}</td>`;
        });
        grand += rowSum;
        body += `<tr><td>${rLabel}</td>${cells}<td class="total-col">${rowSum}</td></tr>`;
      });

      // totals row
      body += `<tr class="total-row"><td>총 합계</td>` +
        colTotals.map(v=>`<td>${v}</td>`).join('') +
        `<td class="total-col">${grand}</td></tr>`;

      body += `</tbody>`;
      setHtml(tableId, head + body);
    }

    function cohortPatients(){
      return activePatients().filter(p => p.isNew && (selPVal===-1 || p.entryPrice===selPVal));
    }

    // -----------------------------
    // 5) 메인 렌더
    // -----------------------------
    function renderAll(){
      document.getElementById('dashArea').classList.remove('hidden');
      document.getElementById('mainContent').classList.remove('hidden');

      const cohort = cohortPatients();
      const hasAgeUnknown = cohort.some(p => (p.ageBucket||'') === '미상');
      const ageCols = hasAgeUnknown ? AGE_BUCKETS : AGE_BUCKETS.filter(a => a !== '미상');
      const hasGenderUnknown = cohort.some(p => (p.gender||'') === '미상');
      const genCols = hasGenderUnknown ? GENDERS : GENDERS.filter(g => g !== '미상');

      
      // Dashboard
      const n = cohort.length;
      const convN = cohort.filter(p => p.shockVisitCount >= 2).length;
      const r3N = cohort.filter(p => p.shockVisitCount >= 3).length;
      const comboN = cohort.filter(p => p.hasInjection).length;

      const shockCounts = cohort.map(p=>p.shockVisitCount);
      const avgV = shockCounts.length ? (shockCounts.reduce((a,b)=>a+b,0)/shockCounts.length) : 0;
      const medV = median(shockCounts);
      const modeV = modeInfo(shockCounts);

      const r7N  = cohort.filter(p => (p.daysTo2 !== null && p.daysTo2 <= 7)).length;
      const r14N = cohort.filter(p => (p.daysTo2 !== null && p.daysTo2 <= 14)).length;

      const selLabel = (selPVal===-1 ? '치료 금액: 전체' : ('치료 금액: ' + selPVal.toLocaleString() + '원'));
      const exclLabel = (exclAmtSet && exclAmtSet.size)
        ? (' · 제외: ' + Array.from(exclAmtSet).sort((a,b)=>a-b).map(v=>v.toLocaleString()+'원').join(', '))
        : '';

      document.getElementById('v-count').textContent = fmtInt(n);
      document.getElementById('v-count-sub').textContent = selLabel + exclLabel;

      document.getElementById('v-conv').textContent = n ? fmtPct(convN/n) : '0%';
      document.getElementById('v-conv-sub').textContent = n ? `${convN}/${n}` : '0/0';

      document.getElementById('v-ret').textContent = n ? fmtPct(r3N/n) : '0%';
      document.getElementById('v-ret-sub').textContent = n ? `${r3N}/${n}` : '0/0';

      document.getElementById('v-combo').textContent = n ? fmtPct(comboN/n) : '0%';
      document.getElementById('v-combo-sub').textContent = n ? `${comboN}/${n}` : '0/0';

      document.getElementById('v-avgV').textContent = avgV.toFixed(1);
      document.getElementById('v-medV').textContent = String(medV);

      const modeLabel = modeV.modes.length ? modeV.modes.join(', ') : '-';
      const modeSub = modeV.maxFreq ? ((modeV.modes.length>1 ? '공동 최빈 · ' : '') + `최대 빈도: ${modeV.maxFreq}명`) : '';
      document.getElementById('v-modeV').textContent = modeLabel;
      document.getElementById('v-modeV-sub').textContent = modeSub;

      document.getElementById('v-r7').textContent = n ? fmtPct(r7N/n) : '0%';
      document.getElementById('v-r7-sub').textContent = n ? `${r7N}/${n}` : '0/0';

      document.getElementById('v-r14').textContent = n ? fmtPct(r14N/n) : '0%';
      document.getElementById('v-r14-sub').textContent = n ? `${r14N}/${n}` : '0/0';

// 표 1: 부위별 치료 횟수 (충격파 row 기준) - 연령대 포함
      const PARTS_BASE = ['목','등','허리','어깨','팔꿈치','손목/손','골반/고관절','무릎','발목/발'];
      const partAge = new Map(); // key: part||age => count
      let hasEtcPart = false;

      cohort.forEach(p => {
        // 같은 방문(방문일) 안에서 부위가 여러 행으로 쪼개지거나(줄바꿈),
        // 한 셀에 '무릎, 발목'처럼 여러 부위가 함께 들어간 경우를 모두 안정적으로 집계한다.
        const byVisit = new Map();
        p.rows.filter(r => isShock(r.typeRaw)).forEach(r => {
          const k = (r.visitKey===null || r.visitKey===undefined) ? 'noDate' : String(r.visitKey);
          if(!byVisit.has(k)) byVisit.set(k, []);
          byVisit.get(k).push(r);
        });

        for(const rows of byVisit.values()){
          const age = (rows.find(x=>x.ageBucket)?.ageBucket) || p.ageBucket || '미상';
          const parts = [];
          rows.forEach(r=>{
            extractParts(r.part).forEach(pt=>{ if(!parts.includes(pt)) parts.push(pt); });
          });
          parts.forEach(part=>{
            if(part === '기타') hasEtcPart = true;
            const kk = part + '||' + age;
            partAge.set(kk, (partAge.get(kk)||0) + 1);
          });
        }
      });

const PARTS = hasEtcPart ? PARTS_BASE.concat(['기타']) : PARTS_BASE;
      renderMatrix('table1', PARTS, ageCols, (pPart, a) => partAge.get(pPart + '||' + a) || 0);

      
      // 표 2: 요약 핵심지표
      const injRate = n ? comboN/n : 0;
      const selTxt = (selPVal===-1 ? '전체' : (selPVal.toLocaleString()+'원'));
      const exclTxt = (exclAmtSet && exclAmtSet.size)
        ? (' / 제외: ' + Array.from(exclAmtSet).sort((a,b)=>a-b).map(v=>v.toLocaleString()+'원').join(', '))
        : '';

      renderKeyValueTable('table2', [
        {k:'신환 수(치료 금액)', v: `${fmtInt(n)}명 / ${selTxt}${exclTxt}`},
        {k:'2회차 전환율', v: n ? fmtPct(convN/n) : '0%'},
        {k:'3회차 유지율', v: n ? fmtPct(r3N/n) : '0%'},
        {k:'주사치료 병행 비율', v: n ? fmtPct(injRate) : '0%'},
        {k:'평균 치료 횟수(충격파)', v: avgV.toFixed(2)},
        {k:'중간값 치료 횟수(충격파)', v: String(medV)},
        {k:'최빈 치료 횟수(충격파)', v: (modeV.modes.length ? modeV.modes.join(', ') : '-')},
        {k:'7일 내 재방문율', v: n ? fmtPct(r7N/n) : '0%'},
        {k:'14일 내 재방문율', v: n ? fmtPct(r14N/n) : '0%'}]);

// 표 3: 연령대별 (신환 수 / 재방문 / 평균 치료 횟수)
      const byAge = new Map(ageCols.map(a=>[a, {patients:0, shockDays:0, revisitPatients:0, revisitCount:0}]));
      cohort.forEach(p => {
        const bucket = ageCols.includes(p.ageBucket) ? p.ageBucket : (ageCols.includes('미상') ? '미상' : ageCols[0]);
        const o = byAge.get(bucket);
        o.patients += 1;
        o.shockDays += p.shockVisitCount;                  // 치료일 수 합(=치료 횟수 합)
        if(p.shockVisitCount >= 2) o.revisitPatients += 1; // 2회 이상 재방문한 사람 수
        o.revisitCount += Math.max(0, p.shockVisitCount - 1); // 재방문 횟수(초진 1회를 제외)
      });

      const t3 = ageCols.map(a=>{
        const o = byAge.get(a) || {patients:0, shockDays:0, revisitPatients:0, revisitCount:0};
        return {
          '연령대': a,
          '신환 수': o.patients,
          '재방문율': o.patients ? fmtPct(o.revisitPatients/o.patients) : '0%',
          '재방문 횟수': o.revisitCount,
          '평균 치료 횟수': o.patients ? (o.shockDays/o.patients).toFixed(2) : '0.00'
        };
      });

      // 합계(전체)
      const totalRevisitCount = shockCounts.reduce((a,c)=>a + Math.max(0, c-1), 0);
      t3.push({
        _rowClass: 'total-row',
        '연령대': '총 합계',
        '신환 수': n,
        '재방문율': n ? fmtPct(convN/n) : '0%',
        '재방문 횟수': totalRevisitCount,
        '평균 치료 횟수': n ? (shockCounts.reduce((a,c)=>a+c,0)/n).toFixed(2) : '0.00'
      });

      renderSimpleTable('table3',
        [{k:'연령대',l:'연령대',w:90},
         {k:'신환 수',l:'신환 수'},
         {k:'재방문율',l:'재방문율(2회 이상)'},
         {k:'재방문 횟수',l:'재방문 횟수'},
         {k:'평균 치료 횟수',l:'평균 치료 횟수'}],
        t3
      );

      // 표 4: 연령대 x 성별 (환자수)
      const sexMat = new Map();
      ageCols.forEach(a=>{
        const m = new Map(); genCols.forEach(g=>m.set(g,0));
        sexMat.set(a,m);
      });
      cohort.forEach(p=>{
        const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        const g = genCols.includes(p.gender) ? p.gender : '미상';
        sexMat.get(a).set(g, sexMat.get(a).get(g) + 1);
      });
      renderMatrix('table4', ageCols, genCols, (age, gen)=> (sexMat.get(age)?.get(gen)) || 0);

      // 표 5: 충격파 방문 횟수 분포 (방문 횟수 x 연령대) - 1~7회 이상까지 표시
const visitBins = ['1회','2회','3회','4회','5회','6회','7회 이상'];
const keepMat = new Map();
visitBins.forEach(b=>{
  const m = new Map(); ageCols.forEach(a=>m.set(a,0));
  keepMat.set(b,m);
});
cohort.forEach(p=>{
  const c = p.shockVisitCount;
  const b = (c>=7) ? '7회 이상' : (c + '회');
  if(!keepMat.has(b)) return;
  const age = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
  keepMat.get(b).set(age, keepMat.get(b).get(age) + 1);
});
renderMatrix('table5', visitBins, ageCols, (bin, age)=> (keepMat.get(bin)?.get(age)) || 0);


      // 표 6: 방문회차 인원 분포 (연령대 x 회차)
      const rounds = ['1회','2회','3회','4회','5회','6회 이상'];
      const distMat = new Map();
      ageCols.forEach(a=>{
        const m = new Map(); rounds.forEach(r=>m.set(r,0));
        distMat.set(a,m);
      });
      cohort.forEach(p=>{
        const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        const c = p.shockVisitCount;
        const r = (c>=6) ? '6회 이상' : (c + '회');
        distMat.get(a).set(r, distMat.get(a).get(r) + 1);
      });
      renderMatrix('table6', ageCols, rounds, (age, round)=> (distMat.get(age)?.get(round)) || 0);

      // 표 7: 치료 금액 구간별 핵심지표
      const actPatients = activePatients();
      const priceSet = Array.from(new Set(
        actPatients.filter(p=>p.isNew)
          .map(p=>p.entryPrice)
          .filter(v=>isFinite(v) && v>0)
      )).sort((a,b)=>a-b);

      const t7 = [];
      let totN = 0, totC2 = 0, totC3 = 0, totInj = 0, totShock = 0;

      priceSet.forEach(price=>{
        const ps = actPatients.filter(p=>p.isNew && p.entryPrice===price);
        const n0 = ps.length;
        const c2 = ps.filter(p=>p.shockVisitCount>=2).length;
        const c3 = ps.filter(p=>p.shockVisitCount>=3).length;
        const inj = ps.filter(p=>p.hasInjection).length;
        const shockSum = ps.reduce((a,p)=>a+p.shockVisitCount,0);
        const avgT = n0 ? (shockSum/n0) : 0;

        totN += n0; totC2 += c2; totC3 += c3; totInj += inj; totShock += shockSum;

        t7.push({
          '치료금액': price.toLocaleString()+'원',
          '신환수': n0,
          '2회차전환': n0 ? fmtPct(c2/n0) : '0%',
          '3회유지': n0 ? fmtPct(c3/n0) : '0%',
          '주사병행': n0 ? fmtPct(inj/n0) : '0%',
          '평균치료': n0 ? avgT.toFixed(2) : '0.00'
        });
      });

      if(priceSet.length){
        t7.push({
          _rowClass: 'total-row',
          '치료금액': '총 합계',
          '신환수': totN,
          '2회차전환': totN ? fmtPct(totC2/totN) : '0%',
          '3회유지': totN ? fmtPct(totC3/totN) : '0%',
          '주사병행': totN ? fmtPct(totInj/totN) : '0%',
          '평균치료': totN ? (totShock/totN).toFixed(2) : '0.00'
        });
      }

      renderSimpleTable('table7',
        [{k:'치료금액',l:'치료 금액',w:110},{k:'신환수',l:'신환수'},
         {k:'2회차전환',l:'2회차 전환'},{k:'3회유지',l:'3회 유지'},
         {k:'주사병행',l:'주사치료 병행'},{k:'평균치료',l:'평균 치료 횟수'}],
        t7
      );

      // 표 8: 치료사별 핵심지표
      const therapists = Array.from(new Set(cohort.map(p=>p.therapist))).sort((a,b)=>a.localeCompare(b));
      const t8 = [];

      therapists.forEach(t=>{
        const ps = cohort.filter(p=>p.therapist===t);
        const n0 = ps.length;
        const c2 = ps.filter(p=>p.shockVisitCount>=2).length;
        const c3 = ps.filter(p=>p.shockVisitCount>=3).length;
        const inj = ps.filter(p=>p.hasInjection).length;
        const shockSum = ps.reduce((a,p)=>a+p.shockVisitCount,0);
        const avgt = n0 ? shockSum/n0 : 0;

        t8.push({
          '치료사': t,
          '신환수': n0,
          '2회차전환': n0 ? fmtPct(c2/n0) : '0%',
          '3회유지': n0 ? fmtPct(c3/n0) : '0%',
          '주사병행': n0 ? fmtPct(inj/n0) : '0%',
          '평균치료': n0 ? avgt.toFixed(2) : '0.00'
        });
      });

      t8.push({
        _rowClass: 'total-row',
        '치료사': '총 합계',
        '신환수': n,
        '2회차전환': n ? fmtPct(convN/n) : '0%',
        '3회유지': n ? fmtPct(r3N/n) : '0%',
        '주사병행': n ? fmtPct(comboN/n) : '0%',
        '평균치료': n ? avgV.toFixed(2) : '0.00'
      });

      renderSimpleTable('table8',
        [{k:'치료사',l:'치료사',w:90},{k:'신환수',l:'신환수'},
         {k:'2회차전환',l:'2회차 전환'},{k:'3회유지',l:'3회 유지'},{k:'주사병행',l:'주사치료 병행'},
         {k:'평균치료',l:'평균 치료 횟수'}],
        t8
      );

      // 표 9: 재방문 주기(첫 충격파 → 2회차)
      const speedBinsAll = ['0-7일','8-14일','15-30일','31-60일','61일 이상','1회만 내원'];
      const spMat = new Map();
      speedBinsAll.forEach(b=>{
        const m = new Map(); ageCols.forEach(a=>m.set(a,0));
        spMat.set(b,m);
      });

      cohort.forEach(p=>{
        const age = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
        let b = '1회만 내원'; // 2회차가 없으면 1회만 내원으로 분류
        if(p.daysTo2 !== null){
          const d = p.daysTo2;
          if(d <= 7) b = '0-7일';
          else if(d <= 14) b = '8-14일';
          else if(d <= 30) b = '15-30일';
          else if(d <= 60) b = '31-60일';
          else b = '61일 이상';
        }
        spMat.get(b).set(age, spMat.get(b).get(age) + 1);
      });

      // 데이터가 없는 구간(예: 30일 이내 데이터면 31-60일/61일 이상)을 자동으로 숨김
      const speedBins = speedBinsAll.filter(bin=>{
        let total = 0;
        ageCols.forEach(a=> total += spMat.get(bin)?.get(a) || 0);
        return total > 0;
      });

      renderMatrix('table9', speedBins, ageCols, (bin, age)=> (spMat.get(bin)?.get(age)) || 0);

            // 제안서 텍스트 (최소 5줄, 조건에 따라 최대 10줄까지 자동 확장)
      const lines = [];
      const marks = ['①','②','③','④','⑤','⑥','⑦','⑧','⑨','⑩','⑪','⑫'];
      const addLine = (htmlLine)=>{
        const m = marks[lines.length] || ((lines.length+1) + '.');
        lines.push(`${m} ${htmlLine}`);
      };

      if(n===0){
        addLine("선택된 조건에 해당하는 신환(충격파) 데이터가 없습니다. 치료금액 필터를 '전체'로 바꾸거나 원본 데이터를 확인해주세요.");
      }else{
        // 기본 5줄 (항상 제공)
        addLine(`<b>2회차 전환율</b>은 <b>${fmtPct(convN/n)}</b> 입니다. <u>첫 치료 당일에 2회차 예약을 선점</u>하고, 미예약자는 <u>재방문 안내 연락 시점(7~10일) 및 예약 확인</u>를 권장합니다.`);
        addLine(`<b>3회차 유지율</b>은 <b>${fmtPct(r3N/n)}</b> 입니다. 3회 이상을 목표로 <u>3~5회 계획</u>을 안내하고, <u>통증/기능 지표</u>를 치료 횟수별로 기록해 동기부여를 강화하세요.`);
        addLine(`<b>주사치료 병행 비율</b>은 <b>${fmtPct(comboN/n)}</b> 입니다. 병행 비중이 높으면 <u>동의/안내/진료 안내 기준</u>을 표준화해 CS를 줄이고, 병행 기준을 팀 내 합의로 정리하세요.`);
        addLine(`<b>7일 내 재방문율</b>은 <b>${fmtPct(r7N/n)}</b>, <b>14일 내 재방문율</b>은 <b>${fmtPct(r14N/n)}</b> 입니다. 7일이 낮고 14일만 높은 경우, <u>예약 대기기간</u>과 <u>스케줄 병목</u>을 우선 점검하세요.`);
        addLine(`치료사별(표 8)로 전환/유지 편차가 크면, <u>초진 설명 문구</u>와 <u>치료 횟수별 목표/기록 템플릿</u>을 통일해 성과를 평준화하는 것이 1순위입니다.`);

        // ---- 추가 인사이트 (조건 충족 시 6~10줄로 확장)
        const oneN = cohort.filter(p => p.shockVisitCount === 1).length;
        if(oneN/n >= 0.35){
          addLine(`<b>1회 종료 비중</b>이 높습니다(<b>${fmtPct(oneN/n)}</b>). 초진에서 <u>‘왜 3회 이상이 필요한지’</u>를 구조적으로 설명하고, <u>2회차 예약/결제 동선</u>을 단순화하세요.`);
        }

        // 치료사 편차(2회차 전환율 기준)
        const tStats = Array.from(new Set(cohort.map(p=>p.therapist))).map(t=>{
          const ps = cohort.filter(p=>p.therapist===t);
          const nn = ps.length;
          const cc2 = ps.filter(p=>p.shockVisitCount>=2).length;
          const rr3 = ps.filter(p=>p.shockVisitCount>=3).length;
          return {t, n: nn, c2: nn?cc2/nn:0, r3: nn?rr3/nn:0};
        }).filter(x=>x.n>=5); // 표본 너무 작은 치료사 제외
        if(tStats.length>=2){
          const maxC2 = Math.max(...tStats.map(x=>x.c2));
          const minC2 = Math.min(...tStats.map(x=>x.c2));
          if((maxC2 - minC2) >= 0.20){
            const best = tStats.reduce((a,b)=> b.c2>a.c2?b:a, tStats[0]);
            const worst = tStats.reduce((a,b)=> b.c2<a.c2?b:a, tStats[0]);
            addLine(`치료사별 <b>2회차 전환율 편차</b>가 큽니다(<b>${fmtPct(maxC2)}</b> vs <b>${fmtPct(minC2)}</b>). <u>${best.t}</u>의 초진 운영을 좋은 사례로 참고하고, <u>${worst.t}</u> 구간은 예약/설명/기록을 코칭하세요.`);
          }
        }

        // 연령대별 병목(2회차 전환율 최저 연령대)
        const aStats = ageCols.map(a=>{
          const ps = cohort.filter(p => (p.ageBucket||'미상') === a);
          const nn = ps.length;
          const cc2 = ps.filter(p=>p.shockVisitCount>=2).length;
          const rr7 = ps.filter(p=>p.daysTo2!==null && p.daysTo2<=7).length;
          return {a, n: nn, c2: nn?cc2/nn:0, r7: nn?rr7/nn:0};
        }).filter(x=>x.n>=10);
        if(aStats.length){
          const worst = aStats.reduce((a,b)=> b.c2<a.c2?b:a, aStats[0]);
          addLine(`<b>${worst.a}</b>에서 <b>2회차 전환</b>이 상대적으로 약합니다. 이 연령대는 <u>예약 시간대(야간/주말)</u>와 <u>커뮤니케이션 채널(SMS/카톡)</u>을 최적화해 개선 여지가 큽니다.`);
        }

        // 치료부위 집중도(상위 1~2개 부위 비중)
        const partCount = new Map();
        cohort.forEach(p=>{
          const parts = new Set();
          p.rows.filter(r=>isShock(r.typeRaw)).forEach(r=>{
            extractParts(r.part).forEach(x=>parts.add(x));
          });
          parts.forEach(pt=>{
            partCount.set(pt, (partCount.get(pt)||0) + 1);
          });
        });
        const topParts = Array.from(partCount.entries()).filter(([k,v])=>k && k!=='(미기입)').sort((a,b)=>b[1]-a[1]).slice(0,2);
        if(topParts.length){
          const p1 = topParts[0];
          const p2 = topParts[1];
          const p1Pct = fmtPct(p1[1]/n);
          const p2Pct = p2 ? fmtPct(p2[1]/n) : null;
          addLine(`주요 치료부위는 <b>${p1[0]}</b>(<b>${p1Pct}</b>)${p2?` · <b>${p2[0]}</b>(<b>${p2Pct}</b>)`:''} 입니다. 상위 부위는 <u>평가/설명 자료</u>와 <u>패키지 구성</u>을 표준화하면 전환 개선 효과가 큽니다.`);
        }
      }

      // 최소 5줄 보장 + 최대 10줄 제한
      while(lines.length < 5 && n>0){
        addLine("표 1~9의 분포를 확인해 <u>전환이 약한 구간</u>부터 우선순위로 개선안을 적용하세요.");
      }
      const MAX_LINES = 10;
      const finalLines = lines.slice(0, MAX_LINES);

document.getElementById('analysisText').innerHTML = finalLines.map(x=>`<div style="margin:4px 0;">${x}</div>`).join('');
    }
  </script>
</body>
</html>
