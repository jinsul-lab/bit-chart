 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/analysis_DOSU_v0.0.5.0.html b/analysis_DOSU_v0.0.5.0.html
index b9c202ea11d5e554b8e9a83261c55630c9b0480c..5edf83b08df46901bdb804da05f4e39ad438e42a 100644
--- a/analysis_DOSU_v0.0.5.0.html
+++ b/analysis_DOSU_v0.0.5.0.html
@@ -1,40 +1,40 @@
 <!DOCTYPE html>
 <html lang="ko">
 <head> <meta charset="UTF-8" /> <title>JINSUL - 전략 분석 시스템 (v 0.0.5.0)</title> <meta name="viewport" content="width=device-width, initial-scale=1" /> <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script> <style> :root { --blue: #228be6; --border: rgba(0, 0, 0, 0.1); --text: #1f2937; --gray: #868e96; } * { box-sizing: border-box; font-family: system-ui, sans-serif; } body { margin: 0; background: #f8f9fa; color: var(--text); min-height: 100vh; display: flex; flex-direction: column; overflow-x: hidden; } .version-tag { position: absolute; top: 10px; left: 10px; font-size: 10px; color: var(--gray); opacity: 0.5; font-weight: bold; } .watermark { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 550px; opacity: 0.1; z-index: -1; pointer-events: none; filter: grayscale(1); } header { padding: 40px 0 20px; text-align: center; } header img { width: 180px; filter: grayscale(1) brightness(0.5); margin-bottom: 10px; } .container { max-width: 1260px; margin: 0 auto; padding: 0 10px; flex: 1; width: 100%; } .card { background: rgba(255, 255, 255, 0); padding: 14px; border-radius: 12px; border: 1px solid var(--border); margin-bottom: 10px; } .card h2 { margin: 0 0 10px; font-size: 16px; border-left: 4px solid var(--blue); padding-left: 10px; } .drop-zone {border: 2px dashed #cbd5e1; padding: 26px; text-align: center; border-radius: 10px; background: rgba(255, 255, 255, 0.5); cursor: pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; width:100%; box-sizing:border-box; min-height:96px; } .drop-zone.active { border-color: var(--blue); background: rgba(34, 139, 230, 0.1); } .cards-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 20px; } @media (max-width: 980px){ .cards-grid{ grid-template-columns: 1fr; } } .dashboard-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(190px, 1fr)); gap: 8px; margin-bottom: 10px; } .dash-item { background: #fff; padding: 12px; border-radius: 10px; border: 1px solid var(--border); text-align: center; } .dash-item .val { font-size: 24px; font-weight: 800; color: var(--blue); } .dash-item .sub { font-size: 11px; color: var(--gray); margin-top: 3px; } .price-btn { padding: 5px 10px; border-radius: 6px; border: 1px solid #dee2e6; background: #fff; cursor: pointer; font-size: 12px; margin: 2px; transition: 0.2s; } .price-btn.active { background: var(--blue); color: #fff; border-color: var(--blue); font-weight: bold; box-shadow: 0 2px 4px rgba(34, 139, 230, 0.3); } .price-btn.excl-btn { border-style: dashed; } .price-btn.excl-btn.active { background: var(--gray); color: #fff; border-color: var(--gray); box-shadow: none; font-weight: bold; } .filter-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; } @media (max-width: 980px){ .filter-grid{ grid-template-columns: 1fr; } } table { width: 100%; border-collapse: collapse; background: transparent; table-layout: fixed; } th { background: rgba(241, 243, 245, 0.85); padding: 7px 6px; border: 1px solid #dee2e6; text-align: center; font-size: 12px; } td { padding: 7px 6px; border: 1px solid var(--border); font-size: 12px; text-align: center; } .total-col { background: rgba(34, 139, 230, 0.1); font-weight: bold; } .total-row td { background: rgba(34, 139, 230, 0.08); font-weight: bold; } .hidden { display: none; } .file-hidden{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; } footer { text-align: center; padding: 30px 20px; color: var(--gray); font-size: 0.95rem; font-weight: 500; width: 100%; position: relative; z-index: 10; } /* --- Added: Subtables & Follow-up summary --- */ .subtablesGrid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(360px, 1fr)); gap:12px; } .miniCard{ border:1px solid #e9ecef; border-radius: 10px; background:#fff; padding:10px; } .miniTitle{ font-weight:700; margin:0 0 6px 0; display:flex; justify-content:space-between; align-items:baseline; font-size:13px; } .miniSub{ font-weight:500; color:#666; font-size:12px; } .mini-table{ width:100%; border-collapse:collapse; table-layout:fixed; } .mini-table th, .mini-table td{ padding:6px 6px; font-size:12px; } .mini-table th{ white-space:nowrap; } .table-scroll{ overflow-x:auto; } .proposalWrap{ display:grid; grid-template-columns: 1fr; gap:12px; align-items:start; } .proposalPanel{ background: rgba(255,255,255,0.75); border:1px solid #d0ebff; border-radius: 12px; padding:12px; }
 @media (max-width: 900px){ .proposalWrap{ grid-template-columns: 1fr; } .subtablesGrid{ grid-template-columns: 1fr; } } .followSummary{ background: rgba(255,255,255,0.75); border:1px solid #d0ebff; border-radius: 12px; padding:12px; } .followSummary .title{ font-weight:700; margin-bottom:6px; } .followSummary ol{ margin:0; padding-left:18px; } .followSummary li{ margin:0 0 8px 0; } .followSummary .meta{ font-size:12px; color:#555; margin-top:2px; } .kpiLines div{ margin:0; } .cardHeaderRow{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
 .toggleBtn{ border:1px solid #cfe3ff; background:#fff; padding:6px 10px; border-radius:10px; font-size:12px; cursor:pointer; }
 .toggleBtn:hover{ background:#f8fbff; }
 .collapseWrap.collapsed{ display:none; }
 .kpiRowLabel{ font-weight:600; }
 </style>
 </head>
 <body> <div class="version-tag">v0.0.5.0</div> <img src="jinsul-logo.png" class="watermark" alt="bg" /> <header> <img src="jinsul-logo.png" alt="logo" /> <div style="font-weight: bold; font-size: 18px;">신환 도수치료 전략 분석 리포트</div> </header> <div class="container"> <div class="card"> <label class="drop-zone" id="dropZone" for="fileInput"> <strong id="statusText">데이터 업로드 (드래그/클릭)</strong> <input type="file" id="fileInput" class="file-hidden" accept=".csv, .xlsx, .xls" /> </label> </div> <div id="dashArea" class="dashboard-grid hidden"> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">신환 수</div> <div id="v-count" class="val">0</div> <div id="v-count-sub" class="sub"></div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">2회차 전환율</div> <div id="v-conv" class="val">0%</div> <div id="v-conv-sub" class="sub"></div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">3회차 도달율</div> <div id="v-ret" class="val">0%</div> <div id="v-ret-sub" class="sub"></div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">주사치료 병행 비율</div> <div id="v-combo" class="val">0%</div> <div id="v-combo-sub" class="sub"></div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">평균 치료 횟수</div> <div id="v-avgV" class="val">0.0</div> <div class="sub">도수치료 치료일 기준</div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">중간값 치료 횟수</div> <div id="v-medV" class="val">0</div> <div class="sub">도수치료 치료일 기준</div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">가장 흔한 치료 횟수(최빈값)</div> <div id="v-modeV" class="val">-</div> <div id="v-modeV-sub" class="sub"></div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">7일 내 재방문율</div> <div id="v-r7" class="val">0%</div> <div id="v-r7-sub" class="sub"></div> </div> <div class="dash-item"> <div style="font-size:12px;color:var(--gray);">14일 내 재방문율</div> <div id="v-r14" class="val">0%</div> <div id="v-r14-sub" class="sub"></div> </div>
 </div> <div id="filterArea" class="card hidden"> <h2>치료 금액 선택</h2> <div class="filter-grid"> <div> <div style="font-size:13px;color:var(--gray);margin-bottom:6px;">포함할 치료 금액 (단일 선택)</div> <div id="priceBtns"></div> </div> <div> <div style="font-size:13px;color:var(--gray);margin-bottom:6px;">제외할 치료 금액 (복수 선택)</div> <div id="excludeBtns"></div> <div style="font-size:12px;color:var(--gray);margin-top:4px;">※ 제외된 금액으로 시작한 신환은 분석에서 제외됩니다.</div> </div> </div>
 </div> <div id="mainContent" class="hidden"> <div class="cards-grid"> <div class="card"><h2>표 1. 진료실별 치료 횟수</h2><div style="overflow-x:auto;"><table id="table1"></table></div></div> <div class="card free-card-main"><div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;"><h2 style="margin:0;">표 1-1. Free(기타여부) → 유료 전환 (기타→신환/재진) (전체)</h2><button id="freeToggleBtn" class="price-btn" type="button">펼치기</button></div><div id="freeTablesMain" style="overflow-x:auto;margin-top:8px;"><table id="table1a_free"></table></div></div> <div class="card free-card-extra"><h2>표 1-2. Free(기타여부) → 유료 전환 (연령대별)</h2><div style="overflow-x:auto;"><table id="table1b_free_age"></table></div></div> <div class="card free-card-extra"><h2>표 1-3. Free(기타여부) → 유료 전환 (치료사별)</h2><div style="overflow-x:auto;"><table id="table1c_free_ther"></table></div></div> <div class="card"><h2>표 2. 신환 상세 통계 및 재진 전환율</h2><div style="overflow-x:auto;"><table id="table2"></table></div></div>
 <div class="card"><h2>표 3. 연령대별 도수치료 치료 건수</h2><div style="overflow-x:auto;"><table id="table3"></table></div></div> <div class="card"><h2>표 4. 연령대별 성별 치료 비중</h2><div style="overflow-x:auto;"><table id="table4"></table></div></div> <div class="card"><h2>표 5. 도수치료 치료 횟수 분포</h2><div style="overflow-x:auto;"><table id="table5"></table></div></div> <div class="card"><h2>표 6. 연령대별 치료 횟수 인원 분포</h2><div style="overflow-x:auto;"><table id="table6"></table></div></div> <div class="card"><h2>표 6-1. 연령대별 치료 횟수 도달율(누적)</h2><div style="overflow-x:auto;"><table id="table6_1"></table></div></div> <div class="card"><h2>표 7. 치료 금액 구간별 핵심지표</h2><div style="overflow-x:auto;"><table id="table7"></table></div></div> <div class="card"><h2>표 8. 치료사별 핵심지표</h2><div style="overflow-x:auto;"><table id="table8"></table></div></div> <div class="card"><h2>표 8-1. 도수치료 치료사별 신환/재진 예약 비율(O/X)</h2><div style="overflow-x:auto;"><table id="table8r"></table></div></div> <div class="card"><h2>표 9. 첫 치료 → 2회차 재방문 주기</h2><div style="overflow-x:auto;"><table id="table9"></table></div></div> <div class="card"><h2>표 10. 진료실별 핵심지표</h2><div style="overflow-x:auto;"><table id="table10"></table></div></div> <div class="card"><h2>표 11. 치료사별·연령대별 평균 치료 횟수</h2><div style="overflow-x:auto;"><table id="table11"></table></div></div> <div class="card"><h2>표 12. 치료사별·연령대별 치료 횟수 분포</h2><div id="table12"></div></div> <div class="card" id="card13"> <div class="cardHeaderRow"> <h2>표 13. 치료사별·연령대별 재방문 안내 연락 시점 및 예약 확인(권장)</h2> <button id="toggle13" class="toggleBtn" type="button">펼치기</button> </div> <div id="table13Wrap" class="collapseWrap collapsed"> <div id="table13"></div> <div id="followSummary13" class="followSummary" style="margin-top:10px;"></div> </div>
-</div> <div class="card" style="background: rgba(231, 245, 255, 0.6);"> <h2>병원 경영 전략 제안서</h2> <div class="proposalWrap"><div id="analysisText" class="proposalPanel" style="line-height:1.7; font-size:13px; color:#333; padding: 12px;"></div></div> </div> </div> </div> </div> <footer>© JINSUL · 경험과 가치를 현실화하는 컨설팅</footer> <script> let freeExpanded = false; // (declared early to avoid TDZ during init) // ----------------------------- // 0) UI 이벤트 // ----------------------------- const dz = document.getElementById('dropZone'); const fi = document.getElementById('fileInput'); // 전역 드래그 기본동작 방지 (드롭 시 브라우저가 파일을 열어버리는 현상 방지) window.addEventListener('dragover', e => e.preventDefault()); window.addEventListener('drop', e => { e.preventDefault(); const f = getDroppedFile(e.dataTransfer); if(f) handleFile(f); }); function getDroppedFile(dt){ if(!dt) return null; if(dt.files && dt.files.length) return dt.files[0]; if(dt.items){ for(const it of dt.items){ if(it && it.kind === 'file') return it.getAsFile(); } } return null; } fi.onchange = e => handleFile(e.target.files && e.target.files[0]); // 클릭 업로드 보장 dz.addEventListener('click', () => fi && fi.click()); // Free(기타여부) 표 펼치기/접기 const freeToggleBtn = document.getElementById('freeToggleBtn'); if(freeToggleBtn){ freeToggleBtn.addEventListener('click', () => setFreeSectionExpanded(!freeExpanded)); } // 기본은 접기 setFreeSectionExpanded(false); // 표 13 펼치기/접기 const toggle13Btn = document.getElementById('toggle13'); const table13Wrap = document.getElementById('table13Wrap'); if(toggle13Btn && table13Wrap){ toggle13Btn.addEventListener('click', ()=>{ const nowCollapsed = table13Wrap.classList.toggle('collapsed'); toggle13Btn.textContent = nowCollapsed ? '펼치기' : '접기'; }); } ['dragenter','dragover'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); dz.classList.add('active'); })); ['dragleave','drop'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); dz.classList.remove('active'); })); dz.addEventListener('drop', e => handleFile(getDroppedFile(e.dataTransfer))); // ----------------------------- // 1) 전역 상태 // ----------------------------- let rawRows = []; let records = []; // row-level cleaned let patientsAll = []; // patient-level aggregated (전체) let selPVal = -1; // selected entry price let entryPriceList = []; let amountListAll = []; let amountListFree = []; let exclAmtSet = new Set(); let exclAmtFreeSet = new Set(); const AGE_BUCKETS = ['10대','20대','30대','40대','50대','60대','70대 이상','미상']; const GENDERS = ['남','여','미상']; function toStr(v){ return (v===null||v===undefined) ? "" : String(v); } function normKey(k){ return toStr(k).trim(); } // 헤더 자동 매핑 강화: 병합/깨짐/2줄 헤더 대응 function _hNorm(s){ return toStr(s).toLowerCase() .replace(/\s+/g,'') .replace(/[()（）\[\]{}]/g,'') .replace(/[·•\-\_\/\\\.]/g,'') .replace(/:+/g,'') .replace(/__empty\d*/g,''); } const _COL_SYNONYMS = [ {std:'번호', syn:['번호','no','#','순번']}, {std:'치료사', syn:['치료사','담당치료사','담당자','시술자','therapist']}, {std:'이름', syn:['이름','환자명','성명','성함','name']}, {std:'환자 차트', syn:['환자차트','환자 차트','차트','차트번호','차트 번호','등록번호','환자번호','chart']}, {std:'성별/연령', syn:['성별/연령','성별연령','성별·연령','성별','연령','나이','sexage']}, {std:'신/재', syn:['신/재','신재','신환/재진','신환재진','구분','초재진']}, {std:'치료부위', syn:['치료부위','부위','시술부위','치료 부위','부위명']}, {std:'치료타입', syn:['치료타입','치료 타입','치료내용','시술','오더','처치','치료종류']}, {std:'회차', syn:['회차','차수','치료회차','치료 회차','횟수','회']}, {std:'금액', syn:['금액','치료금액','수납','결제','청구','amount','price']}, {std:'방문일', syn:['방문일','내원일','진료일','치료일','방문 일자','date']}, {std:'등록일', syn:['등록일','접수일','수납일','등록 일자']}, {std:'예약', syn:['예약','예약여부','예약 여부','예약여부(o/x)']}, {std:'진료실', syn:['진료실','실','room','진료실/구역']}, {std:'비고', syn:['비고','메모','특이사항','note']}, ]; function _stdKeyFromHeader(h){ const hn=_hNorm(h); if(!hn) return ''; for(const item of _COL_SYNONYMS){ for(const s of item.syn){ const sn=_hNorm(s); if(!sn) continue; if(hn===sn || hn.includes(sn) || sn.includes(hn)){ return item.std; } } } return ''; } function _padRows(rows, maxCols){ for(let r=0;r<rows.length;r++){ if(!Array.isArray(rows[r])) rows[r]=[]; for(let c=rows[r].length;c<maxCols;c++) rows[r][c]=''; } } function _applyMergesToRows(rows, merges, maxRow){ if(!merges || !merges.length) return; merges.forEach(m=>{ const r0=m.s.r, r1=m.e.r, c0=m.s.c, c1=m.e.c; if(r0>=maxRow) return; const v = (rows[r0] && rows[r0][c0]!==undefined) ? rows[r0][c0] : ''; if(v===undefined || v===null || toStr(v).trim()==='') return; for(let rr=r0; rr<=Math.min(r1, maxRow-1); rr++){ for(let cc=c0; cc<=c1; cc++){ const cur = rows[rr][cc]; if(cur===undefined || cur===null || toStr(cur).trim()==='') rows[rr][cc]=v; } } }); } function _scoreHeaderRow(headers){ let s=0; headers.forEach(h=>{ const std=_stdKeyFromHeader(h); if(std) s+=3; const hn=_hNorm(h); if(hn && hn.length>=2) s+=0.2; }); return s; } function _detectHeader(rows){ const scan = Math.min(20, rows.length); let best = {score:-1, idx:0, span:1, headers:[]}; for(let i=0;i<scan;i++){ const h1 = rows[i].map(v=>toStr(v).trim()); const s1 = _scoreHeaderRow(h1); if(s1>best.score){ best={score:s1, idx:i, span:1, headers:h1}; } if(i+1<scan){ const h2 = rows[i].map((v,ci)=>{ const a=toStr(v).trim(); const b=toStr(rows[i+1][ci]).trim(); if(a && b && a!==b) return (a+' '+b).trim(); return (a || b).trim(); }); const s2 = _scoreHeaderRow(h2) + 0.3; // 2줄 결합 우선 if(s2>best.score){ best={score:s2, idx:i, span:2, headers:h2}; } } } return best; } function sheetToObjectsAuto(sheet){ try{ const rows = XLSX.utils.sheet_to_json(sheet, {header:1, defval:""}); if(!rows || !rows.length) return []; const maxCols = rows.reduce((m,r)=>Math.max(m, Array.isArray(r)?r.length:0), 0); _padRows(rows, maxCols); const merges = sheet['!merges'] || []; _applyMergesToRows(rows, merges, Math.min(20, rows.length)); const hdr = _detectHeader(rows); const headers = hdr.headers; const colMap = new Map(); headers.forEach((h,ci)=>{ const std = _stdKeyFromHeader(h); if(std) colMap.set(ci, std); }); // fallback: 첫 컬럼은 대개 '번호' if(!Array.from(colMap.values()).includes('번호') && maxCols){ colMap.set(0, '번호'); } const out=[]; const start = hdr.idx + hdr.span; for(let r=start; r<rows.length; r++){ const arr = rows[r]; if(!arr) continue; if(!arr.some(v=>toStr(v).trim()!=='')) continue; const obj={}; for(const [ci,std] of colMap.entries()){ obj[std] = arr[Number(ci)] ?? ""; } out.push(obj); } return out; }catch(err){ console.error('sheetToObjectsAuto failed', err); return []; } }
+</div> <div class="card" style="background: rgba(231, 245, 255, 0.6);"> <h2>병원 경영 전략 제안서</h2> <div class="proposalWrap"><div id="analysisText" class="proposalPanel" style="line-height:1.7; font-size:13px; color:#333; padding: 12px;"></div></div> </div> </div> </div> </div> <footer>© JINSUL · 경험과 가치를 현실화하는 컨설팅</footer> <script> let freeExpanded = false; // (declared early to avoid TDZ during init) // ----------------------------- // 0) UI 이벤트 // ----------------------------- const dz = document.getElementById('dropZone'); const fi = document.getElementById('fileInput'); // 전역 드래그 기본동작 방지 (드롭 시 브라우저가 파일을 열어버리는 현상 방지) window.addEventListener('dragover', e => { e.preventDefault(); e.stopPropagation(); if(e.dataTransfer) e.dataTransfer.dropEffect = 'copy'; }); window.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); const f = getDroppedFile(e.dataTransfer); if(f) handleFile(f); }); function getDroppedFile(dt){ if(!dt) return null; if(dt.files && dt.files.length) return dt.files[0]; if(dt.items){ for(const it of dt.items){ if(it && it.kind === 'file') return it.getAsFile(); } } return null; } fi.onchange = e => handleFile(e.target.files && e.target.files[0]); // 클릭 업로드 보장 dz.addEventListener('click', () => fi && fi.click()); // Free(기타여부) 표 펼치기/접기 const freeToggleBtn = document.getElementById('freeToggleBtn'); if(freeToggleBtn){ freeToggleBtn.addEventListener('click', () => setFreeSectionExpanded(!freeExpanded)); } // 기본은 접기 setFreeSectionExpanded(false); // 표 13 펼치기/접기 const toggle13Btn = document.getElementById('toggle13'); const table13Wrap = document.getElementById('table13Wrap'); if(toggle13Btn && table13Wrap){ toggle13Btn.addEventListener('click', ()=>{ const nowCollapsed = table13Wrap.classList.toggle('collapsed'); toggle13Btn.textContent = nowCollapsed ? '펼치기' : '접기'; }); } ['dragenter','dragover'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); e.stopPropagation(); if(e.dataTransfer) e.dataTransfer.dropEffect = 'copy'; dz.classList.add('active'); })); ['dragleave','drop'].forEach(n => dz.addEventListener(n, e => { e.preventDefault(); e.stopPropagation(); dz.classList.remove('active'); })); dz.addEventListener('drop', e => handleFile(getDroppedFile(e.dataTransfer))); // ----------------------------- // 1) 전역 상태 // ----------------------------- let rawRows = []; let records = []; // row-level cleaned let patientsAll = []; // patient-level aggregated (전체) let selPVal = -1; // selected entry price let entryPriceList = []; let amountListAll = []; let amountListFree = []; let exclAmtSet = new Set(); let exclAmtFreeSet = new Set(); const AGE_BUCKETS = ['10대','20대','30대','40대','50대','60대','70대 이상','미상']; const GENDERS = ['남','여','미상']; function toStr(v){ return (v===null||v===undefined) ? "" : String(v); } function normKey(k){ return toStr(k).trim(); } // 헤더 자동 매핑 강화: 병합/깨짐/2줄 헤더 대응 function _hNorm(s){ return toStr(s).toLowerCase() .replace(/\s+/g,'') .replace(/[()（）\[\]{}]/g,'') .replace(/[·•\-\_\/\\\.]/g,'') .replace(/:+/g,'') .replace(/__empty\d*/g,''); } const _COL_SYNONYMS = [ {std:'번호', syn:['번호','no','#','순번']}, {std:'치료사', syn:['치료사','담당치료사','담당자','시술자','therapist']}, {std:'이름', syn:['이름','환자명','성명','성함','name']}, {std:'환자 차트', syn:['환자차트','환자 차트','차트','차트번호','차트 번호','등록번호','환자번호','chart']}, {std:'성별/연령', syn:['성별/연령','성별연령','성별·연령','성별','연령','나이','sexage']}, {std:'신/재', syn:['신/재','신재','신환/재진','신환재진','구분','초재진']}, {std:'치료부위', syn:['치료부위','부위','시술부위','치료 부위','부위명']}, {std:'치료타입', syn:['치료타입','치료 타입','치료내용','시술','오더','처치','치료종류']}, {std:'회차', syn:['회차','차수','치료회차','치료 회차','횟수','회']}, {std:'금액', syn:['금액','치료금액','수납','결제','청구','amount','price']}, {std:'방문일', syn:['방문일','내원일','진료일','치료일','방문 일자','date']}, {std:'등록일', syn:['등록일','접수일','수납일','등록 일자']}, {std:'예약', syn:['예약','예약여부','예약 여부','예약여부(o/x)']}, {std:'진료실', syn:['진료실','실','room','진료실/구역']}, {std:'비고', syn:['비고','메모','특이사항','note']}, ]; function _stdKeyFromHeader(h){ const hn=_hNorm(h); if(!hn) return ''; for(const item of _COL_SYNONYMS){ for(const s of item.syn){ const sn=_hNorm(s); if(!sn) continue; if(hn===sn || hn.includes(sn) || sn.includes(hn)){ return item.std; } } } return ''; } function _padRows(rows, maxCols){ for(let r=0;r<rows.length;r++){ if(!Array.isArray(rows[r])) rows[r]=[]; for(let c=rows[r].length;c<maxCols;c++) rows[r][c]=''; } } function _applyMergesToRows(rows, merges, maxRow){ if(!merges || !merges.length) return; merges.forEach(m=>{ const r0=m.s.r, r1=m.e.r, c0=m.s.c, c1=m.e.c; if(r0>=maxRow) return; const v = (rows[r0] && rows[r0][c0]!==undefined) ? rows[r0][c0] : ''; if(v===undefined || v===null || toStr(v).trim()==='') return; for(let rr=r0; rr<=Math.min(r1, maxRow-1); rr++){ for(let cc=c0; cc<=c1; cc++){ const cur = rows[rr][cc]; if(cur===undefined || cur===null || toStr(cur).trim()==='') rows[rr][cc]=v; } } }); } function _scoreHeaderRow(headers){ let s=0; headers.forEach(h=>{ const std=_stdKeyFromHeader(h); if(std) s+=3; const hn=_hNorm(h); if(hn && hn.length>=2) s+=0.2; }); return s; } function _detectHeader(rows){ const scan = Math.min(20, rows.length); let best = {score:-1, idx:0, span:1, headers:[]}; for(let i=0;i<scan;i++){ const h1 = rows[i].map(v=>toStr(v).trim()); const s1 = _scoreHeaderRow(h1); if(s1>best.score){ best={score:s1, idx:i, span:1, headers:h1}; } if(i+1<scan){ const h2 = rows[i].map((v,ci)=>{ const a=toStr(v).trim(); const b=toStr(rows[i+1][ci]).trim(); if(a && b && a!==b) return (a+' '+b).trim(); return (a || b).trim(); }); const s2 = _scoreHeaderRow(h2) + 0.3; // 2줄 결합 우선 if(s2>best.score){ best={score:s2, idx:i, span:2, headers:h2}; } } } return best; } function sheetToObjectsAuto(sheet){ try{ const rows = XLSX.utils.sheet_to_json(sheet, {header:1, defval:""}); if(!rows || !rows.length) return []; const maxCols = rows.reduce((m,r)=>Math.max(m, Array.isArray(r)?r.length:0), 0); _padRows(rows, maxCols); const merges = sheet['!merges'] || []; _applyMergesToRows(rows, merges, Math.min(20, rows.length)); const hdr = _detectHeader(rows); const headers = hdr.headers; const colMap = new Map(); headers.forEach((h,ci)=>{ const std = _stdKeyFromHeader(h); if(std) colMap.set(ci, std); }); // fallback: 첫 컬럼은 대개 '번호' if(!Array.from(colMap.values()).includes('번호') && maxCols){ colMap.set(0, '번호'); } const out=[]; const start = hdr.idx + hdr.span; for(let r=start; r<rows.length; r++){ const arr = rows[r]; if(!arr) continue; if(!arr.some(v=>toStr(v).trim()!=='')) continue; const obj={}; for(const [ci,std] of colMap.entries()){ obj[std] = arr[Number(ci)] ?? ""; } out.push(obj); } return out; }catch(err){ console.error('sheetToObjectsAuto failed', err); return []; } }
 function num(v){ const n = parseInt(toStr(v).replace(/[^0-9]/g,''),10); return isFinite(n) ? n : 0; } function moneyOrNull(v){ // 금액 파싱: 숫자가 전혀 없으면 null(없음)로 처리 (공란을 0원으로 만들지 않기 위함) if(v===null || v===undefined) return null; if(typeof v === 'number' && isFinite(v)) return Math.round(v); const digits = toStr(v).replace(/[^0-9]/g,''); if(!digits) return null; const n = parseInt(digits,10); return isFinite(n) ? n : null; } function normalizeType(v){ const s = toStr(v).replace(/\s+/g,'').replace(/,+/g,'').trim(); return s; } function isShock(t){ return normalizeType(t).includes('도수'); } function isInjection(t){ const s=normalizeType(t); return s.includes('주사'); } function isManual(t){ return normalizeType(t).includes('도수'); } function parseVisitDate(v){ // returns Date or null if(v===null || v===undefined || v==="") return null; // number: could be yyyymmdd (e.g., 20251101.0) or excel serial (e.g., 45200) if(typeof v === 'number' && isFinite(v)){ const iv = Math.floor(v); const s = String(iv); if(s.length === 8 && iv > 19000101 && iv < 20991231){ const y = parseInt(s.slice(0,4),10); const m = parseInt(s.slice(4,6),10)-1; const d = parseInt(s.slice(6,8),10); const dt = new Date(y,m,d); return isFinite(dt.getTime()) ? dt : null; } // excel serial heuristic if(iv > 20000 && iv < 60000){ const base = new Date(Date.UTC(1899,11,30)); // Excel epoch const dt = new Date(base.getTime() + iv * 86400000); return isFinite(dt.getTime()) ? new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()) : null; } } // string formats const s0 = toStr(v).trim(); if(!s0) return null; // yyyymmdd as string const s = s0.replace(/\s+/g,''); if(/^\d{8}(\.0+)?$/.test(s)){ const s8 = s.slice(0,8); const y = parseInt(s8.slice(0,4),10); const m = parseInt(s8.slice(4,6),10)-1; const d = parseInt(s8.slice(6,8),10); const dt = new Date(y,m,d); return isFinite(dt.getTime()) ? dt : null; } // yyyy-mm-dd / yyyy/mm/dd const m1 = s.match(/^(\d{4})[-\/.](\d{1,2})[-\/.](\d{1,2})/); if(m1){ const y = parseInt(m1[1],10); const mo = parseInt(m1[2],10)-1; const d = parseInt(m1[3],10); const dt = new Date(y,mo,d); return isFinite(dt.getTime()) ? dt : null; } const dt = new Date(s0); return isFinite(dt.getTime()) ? new Date(dt.getFullYear(), dt.getMonth(), dt.getDate()) : null; } function normalizeRecords(recs){ // 방문(환자+방문일+치료타입+회차+치료사) 단위로 묶어서, // 금액이 비어있는 행(부위가 분리 출력된 행)에도 같은 방문 금액을 전파한다. const g = new Map(); const keyOf = (r)=>[r.key, r.therapist||'', String(r.visitKey||''), normalizeType(r.typeRaw||''), toStr(r.round||'')].join('||'); for(const r of recs){ const k = keyOf(r); if(!g.has(k)) g.set(k, []); g.get(k).push(r); } for(const rows of g.values()){ const amts = rows.map(x=>x.amount).filter(v=>isFinite(v) && v>0); const a = amts.length ? Math.max(...amts) : null; if(a!==null){ rows.forEach(x=>{ if(x.amount===null || x.amount===undefined || x.amount===0) x.amount = a; }); } const t = rows.map(x=>toStr(x.typeRaw).trim()).find(v=>v) || ''; const rd = rows.map(x=>toStr(x.round).trim()).find(v=>v) || ''; const nf = rows.map(x=>toStr(x.newFlag).trim()).find(v=>v) || ''; const rv = rows.map(x=>toStr(x.reserve).trim()).find(v=>v) || ''; const rm = rows.map(x=>toStr(x.room).trim()).find(v=>v) || ''; rows.forEach(x=>{ if(!toStr(x.typeRaw).trim()) x.typeRaw = t; if(!toStr(x.round).trim()) x.round = rd; if(!toStr(x.newFlag).trim()) x.newFlag = nf; if(!toStr(x.reserve).trim()) x.reserve = rv; if(!toStr(x.room).trim()) x.room = rm; }); } return recs; } function dateKey(d){ if(!d) return null; const dd = new Date(d.getFullYear(), d.getMonth(), d.getDate()); return dd.getTime(); } function parseGender(sexAge){ const s = toStr(sexAge); if(s.includes('남')) return '남'; if(s.includes('여')) return '여'; return '미상'; } function parseAgeBucket(sexAge){ const s = toStr(sexAge); const m = s.match(/(\d{1,3})/); if(!m) return '미상'; const age = parseInt(m[1],10); if(!isFinite(age)) return '미상'; if(age < 20) return '10대'; if(age < 30) return '20대'; if(age < 40) return '30대'; if(age < 50) return '40대'; if(age < 60) return '50대'; if(age < 70) return '60대'; return '70대 이상'; } function mapPartSingle(partRaw){
   const s0 = toStr(partRaw).trim();
   if(!s0) return null;
   const s = s0.replace(/\s+/g,'').replace(/[，]/g,'').replace(/,+/g,'').replace(/[.]+$/,'');
   const has = (w)=>s.includes(w);
 
   // '목'이 '손목/발목'에 포함되어 오분류되는 문제 방지: 손/발 먼저 매칭
   if(has('손가락') || has('수지') || has('손목') || (has('손') && !has('발'))) return '손목/손';
   if(has('발가락') || has('족지') || has('발목') || (has('발') && !has('손'))) return '발목/발';
 
   if(has('경추') || (has('목') && !has('손목') && !has('발목'))) return '목';
   if(has('흉추') || (has('등') && !has('허리'))) return '등';
   if(has('요추') || has('허리')) return '허리';
   if(has('어깨') || has('견')) return '어깨';
   if(has('팔꿈치') || has('주관절')) return '팔꿈치';
   if(has('고관절') || has('골반') || has('둔부') || has('엉덩') || has('서혜')) return '골반/고관절';
   if(has('무릎') || has('슬관절')) return '무릎';
   return '기타';
 } function extractParts(partRaw){ const s0 = toStr(partRaw).trim(); if(!s0) return ['(미기입)']; const s = s0 .replace(/\n/g, ',') .replace(/[\/／]/g, ',') .replace(/[·•]/g, ',') .replace(/\s*및\s*/g, ',')
     .replace(/\s*또는\s*/g, ',') .replace(/&/g, ','); const tokens = s.split(',').map(x=>x.trim()).filter(Boolean); const out = []; const push = (v)=>{ if(v && !out.includes(v)) out.push(v); }; if(tokens.length){ tokens.forEach(t=>{ const m = mapPartSingle(t); push(m || '기타'); }); }else{ const m = mapPartSingle(s0); push(m || '기타'); } return out.length ? out : ['(미기입)'];
 } function fmtPct(x){ return (isFinite(x) ? (x*100).toFixed(1) : '0.0') + '%'; } function fmtInt(x){ return (isFinite(x) ? Math.round(x).toLocaleString() : '0'); } function median(arr){ const a = arr.slice().sort((x,y)=>x-y); if(!a.length) return 0; const mid = Math.floor(a.length/2); return a.length%2 ? a[mid] : (a[mid-1]+a[mid])/2; } function modeInfo(arr){ const freq = new Map(); for(const v of (arr||[])){ const k = (v===null||v===undefined) ? null : Number(v); if(!isFinite(k)) continue; freq.set(k, (freq.get(k)||0) + 1); } if(!freq.size) return {modes:[], maxFreq:0}; let maxF = 0; for(const c of freq.values()) maxF = Math.max(maxF, c); const modes = Array.from(freq.entries()).filter(([k,c])=>c===maxF).map(([k])=>k).sort((a,b)=>a-b); return {modes, maxFreq:maxF}; } // ----------------------------- // 2) 파일 로드 -> 정규화 -> 환자 집계 // ----------------------------- function handleFile(file){ if(!file) return; document.getElementById('statusText').textContent = `로드됨: ${file.name}`; const r = new FileReader(); r.onload = e => { const wb = XLSX.read(new Uint8Array(e.target.result), {type:'array'}); const sheet = wb.Sheets[wb.SheetNames[0]]; rawRows = sheetToObjectsAuto(sheet); if(!rawRows || !rawRows.length){ // fallback: 기존 방식 rawRows = XLSX.utils.sheet_to_json(sheet, {defval:""}); }
 buildData(); selPVal = -1; buildPriceButtons(); buildExcludeButtons(); renderAll(); }; r.readAsArrayBuffer(file); } function buildData(){ // 1) 키 정리 const cleaned = rawRows.map(row => { const out = {}; Object.keys(row||{}).forEach(k => out[normKey(k)] = row[k]); return out; }); // 2) 치료사/환자 컨텍스트 ffill let ctx = { therapist:'', name:'', chart:'', sexAge:'', newFlag:'', visitDt:null, typeRaw:'', round:'', room:'' }; const recs = []; for(const r of cleaned){ const no = toStr(r['번호']).trim(); if(no && no.includes('치료사') && no.includes('환자')){ // ex) "김기목 치료사 환자 현황" const t = no.split('치료사')[0].trim(); ctx.therapist = t || ctx.therapist; ctx.name = ''; ctx.chart = ''; ctx.sexAge = ''; ctx.newFlag = ''; ctx.visitDt = null; ctx.typeRaw = ''; ctx.round = ''; ctx.room = ''; continue; // 헤더 행 제외 } const name = toStr(r['이름']).trim(); if(name){ ctx.name = name; const c = toStr(r['환자 차트']).trim(); if(c) ctx.chart = c; const sa = toStr(r['성별/연령']).trim(); if(sa) ctx.sexAge = sa; const nf = toStr(r['신/재']).trim(); if(nf) ctx.newFlag = nf; } // 실제 데이터가 거의 없는 빈 행은 스킵 const rowData = toStr(r['치료부위']).trim() || toStr(r['치료타입']).trim() || toStr(r['치료차수']).trim() || toStr(r['금액']).trim() || toStr(r['방문일']).trim() || toStr(r['등록일']).trim() || toStr(r['진료실']).trim() || toStr(r['예약']).trim() || toStr(r['비고']).trim(); if(!ctx.name || !rowData) continue; let visitDt = parseVisitDate(r['방문일']); if(visitDt) ctx.visitDt = visitDt; else visitDt = ctx.visitDt || null; const vk = dateKey(visitDt); let rt = toStr(r['치료타입']).trim(); if(rt) ctx.typeRaw = rt; else rt = ctx.typeRaw || ''; let round = toStr(r['치료차수']).trim(); if(round) ctx.round = round; else round = ctx.round || ''; let room = toStr(r['진료실']).trim(); if(room) ctx.room = room; else room = ctx.room || ''; const amt = moneyOrNull(r['금액']); const sexAge = toStr(r['성별/연령']).trim() || ctx.sexAge; const newFlag = toStr(r['신/재']).trim() || ctx.newFlag; const chart = toStr(r['환자 차트']).trim() || ctx.chart; const reserveRaw = toStr(r['예약']).trim(); const reserveVal = (()=>{ const v = reserveRaw ? reserveRaw.toUpperCase() : ''; return (v==='O' || v==='X') ? v : ''; })(); recs.push({ therapist: ctx.therapist || '미상', name: ctx.name, chart: chart, key: (chart ? (chart+'|'+ctx.name) : ctx.name), sexAge: sexAge, gender: parseGender(sexAge), ageBucket: parseAgeBucket(sexAge), newFlag: newFlag, part: toStr(r['치료부위']).trim() || '(미기입)', typeRaw: rt, type: normalizeType(rt), amount: amt, visitKey: vk, visitDate: visitDt, reserve: reserveVal, room: room, round: round }); } records = normalizeRecords(recs); patientsAll = computePatientsFrom(records); // 치료 금액(첫 충격파 치료금액) 후보는 데이터에 따라 유동적입니다. amountListAll = Array.from(new Set( patientsAll.filter(p=>p.isNew) .map(p=>p.entryPrice) .filter(v=>isFinite(v) && v>0) )).sort((a,b)=>a-b); // 기타여부(Free) 시작 신환의 진입금액 후보 amountListFree = Array.from(new Set( patientsAll.filter(p=>p.freeStart) .map(p=>p.freeEntryPrice) .filter(v=>isFinite(v) && v>0) )).sort((a,b)=>a-b); exclAmtSet = new Set(); exclAmtFreeSet = new Set(); const hasFreeStart = patientsAll.some(p=>p.freeStart); setFreeSectionExpanded(hasFreeStart); rebuildDerived();
 } function computePatientsFrom(sourceRecords){ const byP = new Map(); for(const row of (sourceRecords||[])){ if(!row.key) continue; if(!byP.has(row.key)) byP.set(row.key, []); byP.get(row.key).push(row); } const pats = []; for(const [pkey, rows] of byP.entries()){ const any = rows[0]; const isNew = rows.some(r => toStr(r.newFlag).includes('신환')); const hasShock = rows.some(r => isShock(r.typeRaw)); const hasInj = rows.some(r => isInjection(r.typeRaw)); const hasMan = rows.some(r => isManual(r.typeRaw)); // 무료→유료 전환(기타여부 → 신환/재진) 계산 (방문일 기준, '첫 상태=기타'일 때만) const rowsSortedByDay = rows.slice().sort((a,b)=>{ const ak = (a.visitKey===null || a.visitKey===undefined) ? 0 : a.visitKey; const bk = (b.visitKey===null || b.visitKey===undefined) ? 0 : b.visitKey; return ak - bk; }); const firstStatusRow = rowsSortedByDay.find(r => toStr(r.newFlag).trim()); const firstStatus = firstStatusRow ? toStr(firstStatusRow.newFlag) : ''; const freeStart = firstStatus.includes('기타'); const freeStartKey = (firstStatusRow && isFinite(firstStatusRow.visitKey)) ? firstStatusRow.visitKey : null; let freeConverted = false; let freeConversionTo = null; let freeConversionKey = null; if(freeStart && freeStartKey!==null){ for(const r of rowsSortedByDay){ if(!isFinite(r.visitKey) || r.visitKey <= freeStartKey) continue; const nf = toStr(r.newFlag); if(nf.includes('신환')){ freeConverted = true; freeConversionTo = '신환'; freeConversionKey = r.visitKey; break; } } } const freeDaysToPaid = (freeConverted && freeConversionKey!==null && freeStartKey!==null) ? Math.round((freeConversionKey - freeStartKey) / 86400000) : null; // Free(기타여부) 시작 금액(해당 방문일의 금액) — (기타) 금액 후보/제외용 let freeEntry = null; if(freeStart && freeStartKey!==null){ const shRowsF = rows.filter(r => r.visitKey===freeStartKey && isShock(r.typeRaw)); const amF1 = shRowsF.map(r=>r.amount).filter(v=>isFinite(v)); freeEntry = amF1.length ? Math.max(...amF1) : null; if(freeEntry===null){ const allRowsF = rows.filter(r => r.visitKey===freeStartKey); const amF2 = allRowsF.map(r=>r.amount).filter(v=>isFinite(v)); freeEntry = amF2.length ? Math.max(...amF2) : null; } } // ✅ 엑셀 기준 신환 귀속: // - 치료사: '신환'으로 표시된 행의 치료사(섹션)로 귀속 (없으면 첫 행 치료사) // - 기준 방문일/금액: '신환' 행의 방문일/금액을 우선 (없으면 기존 로직) const newRows = rows.filter(r => toStr(r.newFlag).includes('신환')); const newTherapist = (newRows.map(r=>toStr(r.therapist).trim()).find(v=>v) || '').trim(); const newVisitKey = (() => { const ks = newRows.map(r=>r.visitKey).filter(Boolean).sort((a,b)=>a-b); return ks.length ? ks[0] : null; })(); const visitKeysAllRaw = new Set(rows.map(r=>r.visitKey).filter(Boolean)); const shockVisitKeysRaw = new Set(rows.filter(r=>isShock(r.typeRaw)).map(r=>r.visitKey).filter(Boolean)); // '충격파'가 명시되지 않은 행(예: 주사치료만 표기)도 엑셀에는 포함될 수 있으므로, // 충격파 방문키가 없으면 전체 방문키를 치료(방문) 기준으로 사용합니다. const primaryVisitKeysRaw = (shockVisitKeysRaw.size ? shockVisitKeysRaw : visitKeysAllRaw); const allKeysRaw = Array.from(visitKeysAllRaw).sort((a,b)=>a-b); const prKeysRaw = Array.from(primaryVisitKeysRaw).sort((a,b)=>a-b); // 신환 기준 시작일(신환 행의 방문일이 있으면 그날부터) — 없으면 기존 첫 방문일 const baseKey = (newVisitKey !== null) ? newVisitKey : (prKeysRaw.length ? prKeysRaw[0] : (allKeysRaw.length ? allKeysRaw[0] : null)); const allKeys = (baseKey===null) ? allKeysRaw : allKeysRaw.filter(k=>k>=baseKey); const prKeys = (baseKey===null) ? prKeysRaw : prKeysRaw.filter(k=>k>=baseKey); const visitKeysAll = new Set(allKeys); const primaryVisitKeys = new Set(prKeys); const firstAll = allKeys.length ? allKeys[0] : null; const firstPrimary = prKeys.length ? prKeys[0] : firstAll; // 진입 금액(= 신환 첫 치료 금액)도 '신환' 행의 방문일을 우선 const entryKey = (newVisitKey !== null) ? newVisitKey : firstPrimary; let entry = null; if(entryKey !== null){ const shRows = rows.filter(r => r.visitKey===entryKey && isShock(r.typeRaw)); const am1 = shRows.map(r=>r.amount).filter(v=>isFinite(v)); entry = am1.length ? Math.max(...am1) : null; if(entry===null){ const allRows = rows.filter(r => r.visitKey===entryKey); const am2 = allRows.map(r=>r.amount).filter(v=>isFinite(v)); entry = am2.length ? Math.max(...am2) : null; } } let entryRoom = ''; if(entryKey !== null){ entryRoom = rows.filter(r=>r.visitKey===entryKey).map(r=>toStr(r.room).trim()).find(v=>v) || ''; } let daysTo2 = null; if(prKeys.length >= 2){ daysTo2 = Math.max(0, Math.round((prKeys[1]-prKeys[0]) / 86400000)); } pats.push({ key: pkey, therapist: (newTherapist || any.therapist || '미상'), name: any.name, chart: any.chart, gender: any.gender, ageBucket: any.ageBucket, isNew: isNew, freeStart: freeStart, freeConverted: freeConverted, freeConversionTo: freeConversionTo, freeDaysToPaid: freeDaysToPaid, freeEntryPrice: freeEntry, entryPrice: entry, entryRoom: entryRoom, visitCountAll: visitKeysAll.size, shockVisitCountRaw: primaryVisitKeys.size, shockVisitCount: Math.min(primaryVisitKeys.size, 5), firstShockKey: firstPrimary, daysTo2: daysTo2, hasInjection: hasInj, hasManual: hasMan, rows: rows }); } return pats; } function patientsAfterFreeExclusion(){ const hasFree = (exclAmtFreeSet && exclAmtFreeSet.size); if(!hasFree) return patientsAll.slice(); return patientsAll.filter(p => { if(p.freeStart && isFinite(p.freeEntryPrice) && exclAmtFreeSet.has(p.freeEntryPrice)) return false; return true; });
 } function activePatients(){ // Free(기타여부) 시작 금액 제외는 전체에 적용 const base = patientsAfterFreeExclusion(); // 일반 금액(유료 진입금액) 제외는 유료(신환) 분석에만 적용 const hasNormal = (exclAmtSet && exclAmtSet.size); if(!hasNormal) return base.slice(); return base.filter(p => { if(!p.isNew || !isFinite(p.entryPrice)) return true; if(exclAmtSet.has(p.entryPrice)) return false; return true; });
 } function rebuildDerived(){ const act = activePatients(); entryPriceList = Array.from(new Set( act.filter(p=>p.isNew) .map(p=>p.entryPrice) .filter(v=>isFinite(v) && v>0) )).sort((a,b)=>a-b); // 선택 금액이 더 이상 존재하지 않으면 '전체'로 복귀 if(selPVal !== -1 && !entryPriceList.includes(selPVal)) selPVal = -1;
@@ -135,56 +135,57 @@ const comboN = cohort.filter(p => p.hasInjection).length; const shockCounts = co
         '무료 시작': `${fmtInt(o.free)}명`,
         '전체 전환': `${fmtInt(o.any)}명`,
         '전체 전환율': o.free ? fmtPct(o.any/o.free) : '0%',
         '동일 부위 전환': `${fmtInt(o.same)}명`,
         '동일 부위 전환율': o.free ? fmtPct(o.same/o.free) : '0%',
         '동일부위+동일치료사': `${fmtInt(o.attr)}명`,
         '동일부위+동일치료사율': o.free ? fmtPct(o.attr/o.free) : '0%'
       }));
       renderSimpleTable('table1c_free_ther', [
         {k:'치료사',l:'치료사',w:90},
         {k:'무료 시작',l:'무료 시작'},
         {k:'전체 전환',l:'전체 전환'},
         {k:'전체 전환율',l:'전체 전환율'},
         {k:'동일 부위 전환',l:'동일 부위 전환'},
         {k:'동일 부위 전환율',l:'동일 부위 전환율'},
         {k:'동일부위+동일치료사',l:'동일부위+동일치료사'},
         {k:'동일부위+동일치료사율',l:'동일부위+동일치료사율'}
       ], freeTherRows);
 // 표 2: 요약 핵심지표 const injRate = n ? comboN/n : 0; const selTxt = (selPVal===-1 ? '전체' : (selPVal.toLocaleString()+'원')); const exclTxt = (() => { const parts = []; if(exclAmtSet && exclAmtSet.size){ parts.push(...Array.from(exclAmtSet).sort((a,b)=>a-b).map(v=>v.toLocaleString()+'원')); } if(exclAmtFreeSet && exclAmtFreeSet.size){ parts.push(...Array.from(exclAmtFreeSet).sort((a,b)=>a-b).map(v=>v.toLocaleString()+'원(기타)')); } return parts.length ? (' / 제외: ' + parts.join(', ')) : ''; })(); renderKeyValueTable('table2', [ {k:'신환 수(치료 금액)', v: `${fmtInt(n)}명 / ${selTxt}${exclTxt}`}, {k:'2회차 전환율', v: n ? `${fmtPct(convN/n)} (${fmtInt(convN)}/${fmtInt(n)})` : '0% (0/0)'}, {k:'3회차 도달율', v: n ? `${fmtPct(r3N/n)} (${fmtInt(r3N)}/${fmtInt(n)})` : '0% (0/0)'}, {k:'주사치료 병행 비율', v: n ? fmtPct(injRate) : '0%'}, {k:'평균 치료 횟수', v: avgV.toFixed(2)}, {k:'중간값 치료 횟수', v: (medV>=5 ? '5회 이상' : String(medV))}, {k:'최빈 치료 횟수', v: (modeV.modes.length ? Array.from(new Set(modeV.modes.map(v=> (v>=5 ? '5회 이상' : String(v))))).join(', ') : '-')}, {k:'7일 내 재방문율', v: n ? fmtPct(r7N/n) : '0%'}, {k:'14일 내 재방문율', v: n ? fmtPct(r14N/n) : '0%'}]); // 표 3: 연령대별 (신환 수 / 재방문 / 평균 치료 횟수) const byAge = new Map(ageCols.map(a=>[a, {patients:0, shockDays:0, revisitPatients:0, revisitCount:0}])); cohort.forEach(p => { const bucket = ageCols.includes(p.ageBucket) ? p.ageBucket : (ageCols.includes('미상') ? '미상' : ageCols[0]); const o = byAge.get(bucket); o.patients += 1; o.shockDays += p.shockVisitCount; // 치료일 수 합(=치료 횟수 합) if(p.shockVisitCount >= 2) o.revisitPatients += 1; // 2회 이상 재방문한 사람 수 o.revisitCount += Math.max(0, p.shockVisitCount - 1); // 재방문 횟수(초진 1회를 제외) }); const t3 = ageCols.map(a=>{ const o = byAge.get(a) || {patients:0, shockDays:0, revisitPatients:0, revisitCount:0}; return { '연령대': a, '신환 수': o.patients, '재방문율': o.patients ? fmtPct(o.revisitPatients/o.patients) : '0%', '재방문 횟수': o.revisitCount, '평균 치료 횟수': o.patients ? (o.shockDays/o.patients).toFixed(2) : '0.00' }; }); // 합계(전체) const totalRevisitCount = shockCounts.reduce((a,c)=>a + Math.max(0, c-1), 0); t3.push({ _rowClass: 'total-row', '연령대': '총 합계', '신환 수': n, '재방문율': n ? fmtPct(convN/n) : '0%', '재방문 횟수': totalRevisitCount, '평균 치료 횟수': n ? (shockCounts.reduce((a,c)=>a+c,0)/n).toFixed(2) : '0.00' }); renderSimpleTable('table3', [{k:'연령대',l:'연령대',w:90}, {k:'신환 수',l:'신환 수'}, {k:'재방문율',l:'재방문율(2회 이상)'}, {k:'재방문 횟수',l:'재방문 횟수'}, {k:'평균 치료 횟수',l:'평균 치료 횟수'}], t3 ); // 표 4: 연령대 x 성별 (환자수) const sexMat = new Map(); ageCols.forEach(a=>{ const m = new Map(); genCols.forEach(g=>m.set(g,0)); sexMat.set(a,m); }); cohort.forEach(p=>{ const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상'; const g = genCols.includes(p.gender) ? p.gender : '미상'; sexMat.get(a).set(g, sexMat.get(a).get(g) + 1); }); renderMatrix('table4', ageCols, genCols, (age, gen)=> (sexMat.get(age)?.get(gen)) || 0); // 표 5: 충격파 방문 횟수 분포 (방문 횟수 x 연령대) - 1~5회 이상까지 표시
 const visitBins = ['1회만','2회만','3회만','4회만','5회 이상'];
 const keepMat = new Map();
 visitBins.forEach(b=>{ const m = new Map(); ageCols.forEach(a=>m.set(a,0)); keepMat.set(b,m);
 });
 cohort.forEach(p=>{ const c = p.shockVisitCount; const b = (c>=5) ? '5회 이상' : (c + '회만'); if(!keepMat.has(b)) return; const age = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상'; keepMat.get(b).set(age, keepMat.get(b).get(age) + 1);
 });
+renderMatrix('table5', visitBins, ageCols, (bin, age)=> (keepMat.get(bin)?.get(age)) || 0); // 표 6: 방문회차 인원 분포 (연령대 x 회차) const rounds = ['1회만','2회만','3회만','4회만','5회 이상']; const distMat = new Map(); ageCols.forEach(a=>{ const m = new Map(); rounds.forEach(r=>m.set(r,0)); distMat.set(a,m); }); cohort.forEach(p=>{ const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상'; const c = p.shockVisitCount; const r = (c>=5) ? '5회 이상' : (c + '회만'); distMat.get(a).set(r, distMat.get(a).get(r) + 1); });
       const ageTotals2 = new Map();
       ageCols.forEach(a=>{
         let s=0; rounds.forEach(r=>{ s += (distMat.get(a)?.get(r) || 0); });
         ageTotals2.set(a, s);
       });
-renderMatrix('table5', visitBins, ageCols, (bin, age)=> (keepMat.get(bin)?.get(age)) || 0); // 표 6: 방문회차 인원 분포 (연령대 x 회차) const rounds = ['1회만','2회만','3회만','4회만','5회 이상']; const distMat = new Map(); ageCols.forEach(a=>{ const m = new Map(); rounds.forEach(r=>m.set(r,0)); distMat.set(a,m); }); cohort.forEach(p=>{ const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상'; const c = p.shockVisitCount; const r = (c>=5) ? '5회 이상' : (c + '회만'); distMat.get(a).set(r, distMat.get(a).get(r) + 1); }); renderMatrix('table6', ageCols, rounds, (age, round)=>{
+      renderMatrix('table6', ageCols, rounds, (age, round)=>{
         const cnt = (distMat.get(age)?.get(round)) || 0;
         const tot = ageTotals2.get(age) || 0;
         const disp = tot ? `${fmtInt(cnt)}명 (${fmtPct(cnt/tot)})` : `${fmtInt(cnt)}명 (0%)`;
         return [cnt, disp];
       }); // 표 6-1: 연령대별 치료 횟수 도달율(누적)
       const reachCols = ['1회 이상','2회 이상','3회 이상','4회 이상','5회 이상'];
       const reachMat = new Map();
       const ageTotals = new Map();
       ageCols.forEach(a=>{
         const m = new Map(); reachCols.forEach(r=>m.set(r,0));
         reachMat.set(a,m);
         ageTotals.set(a,0);
       });
       cohort.forEach(p=>{
         const a = AGE_BUCKETS.includes(p.ageBucket) ? p.ageBucket : '미상';
         ageTotals.set(a, (ageTotals.get(a)||0) + 1);
         const cRaw = isFinite(p.shockVisitCountRaw) ? p.shockVisitCountRaw : p.shockVisitCount;
         const c = isFinite(cRaw) ? cRaw : 0;
         if(c>=1) reachMat.get(a).set('1회 이상', (reachMat.get(a).get('1회 이상')||0) + 1);
         if(c>=2) reachMat.get(a).set('2회 이상', (reachMat.get(a).get('2회 이상')||0) + 1);
         if(c>=3) reachMat.get(a).set('3회 이상', (reachMat.get(a).get('3회 이상')||0) + 1);
         if(c>=4) reachMat.get(a).set('4회 이상', (reachMat.get(a).get('4회 이상')||0) + 1);
         if(c>=5) reachMat.get(a).set('5회 이상', (reachMat.get(a).get('5회 이상')||0) + 1);
       });
       renderMatrixNoTotals('table6_1', ageCols, reachCols, (age, col)=>{
 
EOF
)
